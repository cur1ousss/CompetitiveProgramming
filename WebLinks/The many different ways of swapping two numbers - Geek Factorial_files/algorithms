// API callback
related_results_labels_thumbs({"version":"1.0","encoding":"UTF-8","feed":{"xmlns":"http://www.w3.org/2005/Atom","xmlns$openSearch":"http://a9.com/-/spec/opensearchrss/1.0/","xmlns$blogger":"http://schemas.google.com/blogger/2008","xmlns$georss":"http://www.georss.org/georss","xmlns$gd":"http://schemas.google.com/g/2005","xmlns$thr":"http://purl.org/syndication/thread/1.0","id":{"$t":"tag:blogger.com,1999:blog-4840603379647116080"},"updated":{"$t":"2019-06-10T14:01:16.582+05:30"},"category":[{"term":"programming"},{"term":"c"},{"term":"puzzles"},{"term":"algorithms"},{"term":"divide and conquer"},{"term":"bit manipulation"},{"term":"logical puzzles"},{"term":"brain teasers"},{"term":"lateral thinking"},{"term":"math and number puzzles"},{"term":"css"},{"term":"geek factorial"},{"term":"html"},{"term":"java"},{"term":"miscellaneous"},{"term":"web design"}],"title":{"type":"text","$t":"Geek Factorial"},"subtitle":{"type":"html","$t":"Programming problems • Geek life • Logical puzzles • \u0026amp; more"},"link":[{"rel":"http://schemas.google.com/g/2005#feed","type":"application/atom+xml","href":"https:\/\/geekfactorial.blogspot.com\/feeds\/posts\/default"},{"rel":"self","type":"application/atom+xml","href":"https:\/\/www.blogger.com\/feeds\/4840603379647116080\/posts\/default\/-\/algorithms?alt=json-in-script\u0026max-results=8"},{"rel":"alternate","type":"text/html","href":"https:\/\/geekfactorial.blogspot.com\/search\/label\/algorithms"},{"rel":"hub","href":"http://pubsubhubbub.appspot.com/"}],"author":[{"name":{"$t":"Unknown"},"email":{"$t":"noreply@blogger.com"},"gd$image":{"rel":"http://schemas.google.com/g/2005#thumbnail","width":"16","height":"16","src":"https:\/\/img1.blogblog.com\/img\/b16-rounded.gif"}}],"generator":{"version":"7.00","uri":"http://www.blogger.com","$t":"Blogger"},"openSearch$totalResults":{"$t":"7"},"openSearch$startIndex":{"$t":"1"},"openSearch$itemsPerPage":{"$t":"8"},"entry":[{"id":{"$t":"tag:blogger.com,1999:blog-4840603379647116080.post-8580898793592244625"},"published":{"$t":"2016-08-15T14:00:00.000+05:30"},"updated":{"$t":"2016-08-16T15:21:34.102+05:30"},"category":[{"scheme":"http://www.blogger.com/atom/ns#","term":"algorithms"},{"scheme":"http://www.blogger.com/atom/ns#","term":"programming"}],"title":{"type":"text","$t":"The many different ways of swapping two numbers"},"content":{"type":"html","$t":"\u003Cdiv dir=\"ltr\" style=\"text-align: left;\" trbidi=\"on\"\u003EOne of the most seen snippets of code is the one that swaps the values of two variables. This little job is crucial to many algorithms, and there are multiple ways of doing it. Generally, for swapping two variables we use a temporary third variable, but various other ways do not even require the help of any third variable.\u003Cbr \/\u003E\u003Cdiv class=\"separator\" style=\"clear: both; text-align: center;\"\u003E\u003Ca href=\"https:\/\/1.bp.blogspot.com\/-S4rCg9H-chM\/V7Fy-fLLLjI\/AAAAAAAAAfs\/ehW6g-nFEwIqZ9ng0vcBy2djhTTZDH8fACLcB\/s1600\/lets-swap-it.jpg\" imageanchor=\"1\" style=\"margin-left: 1em; margin-right: 1em;\"\u003E\u003Cimg border=\"0\" height=\"281\" src=\"https:\/\/1.bp.blogspot.com\/-S4rCg9H-chM\/V7Fy-fLLLjI\/AAAAAAAAAfs\/ehW6g-nFEwIqZ9ng0vcBy2djhTTZDH8fACLcB\/s640\/lets-swap-it.jpg\" width=\"640\" \/\u003E\u003C\/a\u003E\u003C\/div\u003EI find it very interesting that there are so many ways of doing this seemingly simple job and so, I thought to share all the ways I know of swapping two numbers...\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cb\u003E1. The simple method using a third variable\u003C\/b\u003E\u003Cbr \/\u003E\u003Cpre class=\"brush:cpp; highlight:[7, 8, 9]; code\"\u003E#include \u0026lt;stdio.h\u0026gt;\u003Cbr \/\u003Eint main()\u003Cbr \/\u003E{\u003Cbr \/\u003E    int a = 10, b = 5, temp;\u003Cbr \/\u003E\u003Cbr \/\u003E    \/\/ Code to swap a and b:\u003Cbr \/\u003E    temp = a;\u003Cbr \/\u003E    a = b;\u003Cbr \/\u003E    b = temp;\u003Cbr \/\u003E\u003Cbr \/\u003E    printf(\"After swapping: a = %d, b = %d\", a, b);\u003Cbr \/\u003E    return 0;\u003Cbr \/\u003E}\u003Cbr \/\u003E\u003C\/pre\u003E\u003Cbr \/\u003ENow let's look at some methods which do not require any additional variables.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cb\u003E2. Using arithmetic operators + and -\u003C\/b\u003E\u003Cbr \/\u003E\u003Cpre class=\"brush:cpp; code\"\u003Ea = a + b;\u003Cbr \/\u003Eb = a - b;\u003Cbr \/\u003Ea = a - b;\u003Cbr \/\u003E\u003C\/pre\u003EThe above way works well, but it may cause arithmetic overflow when adding large numbers.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cb\u003E3. Using arithmetic operators * and \/\u003C\/b\u003E\u003Cbr \/\u003E\u003Cpre class=\"brush:cpp; code\"\u003Ea = a * b;\u003Cbr \/\u003Eb = a \/ b;\u003Cbr \/\u003Ea = a \/ b;\u003Cbr \/\u003E\u003C\/pre\u003EThis way will not work if one of the numbers is zero, as the product becomes zero. It may also cause arithmetic overflow when multiplying large numbers.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cb\u003E4. Using bitwise XOR operator ^\u003C\/b\u003E\u003Cbr \/\u003E\u003Cpre class=\"brush:cpp; code\"\u003Ea = a ^ b;\u003Cbr \/\u003Eb = a ^ b;\u003Cbr \/\u003Ea = a ^ b;\u003Cbr \/\u003E\u003C\/pre\u003EThis method is perhaps a bit more efficient, because it uses bitwise operator only. It can also be written in a more compact manner like this:\u003Cbr \/\u003E\u003Cpre class=\"brush:cpp; code\"\u003Ea ^= b;\u003Cbr \/\u003Eb ^= a;\u003Cbr \/\u003Ea ^= b;\u003Cbr \/\u003E\u003C\/pre\u003E\u003Cbr \/\u003E\u003Cb\u003ENote:\u003C\/b\u003E When using pointers to the variables, \u003Ci\u003Ethe above methods 2, 3 and 4 will fail if both the pointers point to the same variable\u003C\/i\u003E. Example: If a function to swap two variables is accepting the addresses of the two variables, then a call like \u003Ci\u003Eswap(\u0026a, \u0026a);\u003C\/i\u003E should make no effect on the value of variable a, but in the above methods (except method 1) the variable will store incorrect value. So, we need to firstly check if both the pointers are exactly the same. A good example of using the above swap methods with pointers can be like:\u003Cbr \/\u003E\u003Cpre class=\"brush:cpp; code\"\u003Evoid swap(int *x, int *y)\u003Cbr \/\u003E{\u003Cbr \/\u003E    if(x != y)    \/\/ Checking that x and y are not pointing to the same location\u003Cbr \/\u003E    {\u003Cbr \/\u003E        *x ^= *y;\u003Cbr \/\u003E        *y ^= *x;\u003Cbr \/\u003E        *x ^= *y;\u003Cbr \/\u003E    }\u003Cbr \/\u003E}\u003Cbr \/\u003E\u003C\/pre\u003E\u003Cbr \/\u003E\u003Cb\u003E5. Using bitwise XOR operator ^ in one line\u003C\/b\u003E\u003Cbr \/\u003E\u003Cpre class=\"brush:cpp; code\"\u003Ea ^= b ^= a ^= b;\u003Cbr \/\u003E\u003C\/pre\u003EThis is similar to method 4 but three statements have been compounded into one. Order of evaluation is from right to left.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cb\u003E6. Using arithmetic operators + and - in one line\u003C\/b\u003E\u003Cbr \/\u003E\u003Cpre class=\"brush:cpp; code\"\u003Ea = (a + b) - (b = a);\u003Cbr \/\u003E\u003C\/pre\u003EThe problem of arithmetic overflow can occur in this method.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cb\u003E7. Using arithmetic operators * and \/ in one line\u003C\/b\u003E\u003Cbr \/\u003E\u003Cpre class=\"brush:cpp; code\"\u003Ea = (a * b) \/ (b = a);\u003Cbr \/\u003E\u003C\/pre\u003EThe problem of arithmetic overflow can occur in this method. Also, it will show undefined behavior if the first number a = 0 (because that will lead to division by zero).\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cb\u003E8. Using arithmetic operators + and - in a slightly different way\u003C\/b\u003E\u003Cbr \/\u003E\u003Cpre class=\"brush:cpp; code\"\u003Ea = b - a;\u003Cbr \/\u003Eb = b - a;\u003Cbr \/\u003Ea = b + a;\u003Cbr \/\u003E\u003C\/pre\u003ENote that the corresponding method with * and \/ operators does not work.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cb\u003ENote:\u003C\/b\u003E The methods 5, 6, 7 and 8 also work well when using pointers to the variables. But \u003Ci\u003Emethods 5 and 8 will give wrong result if the pointers point to the same location\u003C\/i\u003E.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cb\u003E9. Using a file as buffer\u003C\/b\u003E\u003Cbr \/\u003E\u003Cpre class=\"brush:cpp; code\"\u003EFILE *fp;\u003Cbr \/\u003E\u003Cbr \/\u003Efprintf(fp = fopen(\"temp.txt\", \"w\"), \"%d\", a);\u003Cbr \/\u003Efclose(fp);\u003Cbr \/\u003Ea = b;\u003Cbr \/\u003Efscanf(fp = fopen(\"temp.txt\", \"r\"), \"%d\", \u0026b);\u003Cbr \/\u003Efclose(fp);\u003Cbr \/\u003E\u003C\/pre\u003EOf course, using such a method incurs a lot more overhead than the usual methods. Just included for theoretical purposes.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cb\u003E10. Using a \u003Ca href=\"https:\/\/geekfactorial.blogspot.com\/2016\/08\/command-line-arguments-and-their-implementation-in-c.html\"\u003Ecommand-line-related variable\u003C\/a\u003E as buffer\u003C\/b\u003E\u003Cbr \/\u003E\u003Cpre class=\"brush:cpp; code\"\u003Eint main(int argc, char **argv)\u003Cbr \/\u003E{\u003Cbr \/\u003E    int a = 10, b = 5;\u003Cbr \/\u003E\u003Cbr \/\u003E    argc = a;\u003Cbr \/\u003E    a = b;\u003Cbr \/\u003E    b = argc;\u003Cbr \/\u003E\u003Cbr \/\u003E    printf(\"After swapping: a = %d, b = %d\", a, b);\u003Cbr \/\u003E    return 0;\u003Cbr \/\u003E}\u003Cbr \/\u003E\u003C\/pre\u003E\u003Cbr \/\u003E\u003Cb\u003E11. Using a macro\u003C\/b\u003E\u003Cbr \/\u003E\u003Cpre class=\"brush:cpp; code\"\u003E#define SWAP(x, y, Type) Type temp = x; x = y; y = temp;\u003Cbr \/\u003E\u003Cbr \/\u003Eint main()\u003Cbr \/\u003E{\u003Cbr \/\u003E    int a = 10, b = 5;\u003Cbr \/\u003E\u003Cbr \/\u003E    SWAP(a, b, int);\u003Cbr \/\u003E\u003Cbr \/\u003E    printf(\"After swapping: a = %d, b = %d\", a, b);\u003Cbr \/\u003E    return 0;\u003Cbr \/\u003E}\u003Cbr \/\u003E\u003C\/pre\u003EIts advantage is that it is generic up to some extent. The same SWAP macro will work for types like int, float and char. By using this GCC-specific extension, we can improve it further like:\u003Cbr \/\u003E\u003Cpre class=\"brush:cpp; code\"\u003E#define SWAP(x, y) typeof(x) temp = x; x = y; y = temp;\u003Cbr \/\u003E\u003C\/pre\u003EThe problem with method 11 will arise when there is already a variable named temp in the program!\u003Cbr \/\u003E\u003C\/div\u003E"},"link":[{"rel":"replies","type":"application/atom+xml","href":"https:\/\/geekfactorial.blogspot.com\/feeds\/8580898793592244625\/comments\/default","title":"Post Comments"},{"rel":"replies","type":"text/html","href":"https:\/\/geekfactorial.blogspot.com\/2016\/08\/the-many-different-ways-of-swapping-two-numbers.html#comment-form","title":"0 Comments"},{"rel":"edit","type":"application/atom+xml","href":"https:\/\/www.blogger.com\/feeds\/4840603379647116080\/posts\/default\/8580898793592244625"},{"rel":"self","type":"application/atom+xml","href":"https:\/\/www.blogger.com\/feeds\/4840603379647116080\/posts\/default\/8580898793592244625"},{"rel":"alternate","type":"text/html","href":"https:\/\/geekfactorial.blogspot.com\/2016\/08\/the-many-different-ways-of-swapping-two-numbers.html","title":"The many different ways of swapping two numbers"}],"author":[{"name":{"$t":"Unknown"},"email":{"$t":"noreply@blogger.com"},"gd$image":{"rel":"http://schemas.google.com/g/2005#thumbnail","width":"16","height":"16","src":"https:\/\/img1.blogblog.com\/img\/b16-rounded.gif"}}],"media$thumbnail":{"xmlns$media":"http://search.yahoo.com/mrss/","url":"https:\/\/1.bp.blogspot.com\/-S4rCg9H-chM\/V7Fy-fLLLjI\/AAAAAAAAAfs\/ehW6g-nFEwIqZ9ng0vcBy2djhTTZDH8fACLcB\/s72-c\/lets-swap-it.jpg","height":"72","width":"72"},"thr$total":{"$t":"0"}},{"id":{"$t":"tag:blogger.com,1999:blog-4840603379647116080.post-1159264033540602758"},"published":{"$t":"2016-08-10T19:18:00.000+05:30"},"updated":{"$t":"2016-08-11T14:18:22.892+05:30"},"category":[{"scheme":"http://www.blogger.com/atom/ns#","term":"algorithms"},{"scheme":"http://www.blogger.com/atom/ns#","term":"c"},{"scheme":"http://www.blogger.com/atom/ns#","term":"divide and conquer"},{"scheme":"http://www.blogger.com/atom/ns#","term":"programming"}],"title":{"type":"text","$t":"Binary Search in sorted and shifted (rotated) array"},"content":{"type":"html","$t":"\u003Cdiv dir=\"ltr\" style=\"text-align: left;\" trbidi=\"on\"\u003EWe know that \u003Ca href=\"https:\/\/geekfactorial.blogspot.in\/2016\/08\/binary-search.html\"\u003EBinary Search\u003C\/a\u003E can be used to find an element in a sorted array of elements in O(log n) time. The algorithm is very versatile and with little modifications, it can be utilized in many more places for efficiency. Let us see one such problem.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cb\u003EProblem statement:\u003C\/b\u003E You've been given an array that is sorted and then rotated by some unknown offset. For example, consider a sorted array arr[] = {1, 2, 3, 4, 5}. This array is now rotated, say twice, to the right such that arr[] = {4, 5, 1, 2, 3}. The offset of rotation is not known to you for a given array. Devise a way to find an element in the rotated array in O(log n) time.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cb\u003EModified Binary Search approach:\u003C\/b\u003E Now how efficiently can one search in this sorted + rotated array? The key is to find the offset position, i.e. the position at which array order is changed. For example, in the above array arr[], the offset position can be taken as index 1 (where element 5 is stored) because the very next element is the actual starting element of the sorted array, which is the smallest element. It can be seen that the array is divided into \u003Ci\u003Etwo sorted sub-arrays\u003C\/i\u003E at the offset position.\u003Cbr \/\u003E\u003Cbr \/\u003ESo, if the offset is known to us, we can apply Binary Search in the two sorted sub-arrays one by one to find out the element in O(log n) time. Now all we have to worry about is finding the offset, and that too in O(log n) running time. This can be accomplished via a modified Binary Search, which considers the fact that \u003Ci\u003Ethe offset element is the only element in the array for which the very next element to it is smaller\u003C\/i\u003E. By using this as a condition, we can find the offset.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cb\u003ESolution:\u003C\/b\u003E Here is a C program which implements the above approach.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cpre class = \"brush:cpp; code\"\u003E#include \u0026lt;stdio.h\u0026gt;\u003Cbr \/\u003E\u003Cbr \/\u003E\/* Function to find the offset position in O(log n) via modified Binary Search *\/\u003Cbr \/\u003Eint findOffset(int *arr, int low, int high, int size)\u003Cbr \/\u003E{\u003Cbr \/\u003E    int mid;\u003Cbr \/\u003E    if (low \u0026lt;= high)\u003Cbr \/\u003E    {\u003Cbr \/\u003E        mid = low + ((high - low) \/ 2);\u003Cbr \/\u003E\u003Cbr \/\u003E        if (arr[mid] \u0026gt; arr[mid+1])\u003Cbr \/\u003E            \/* Offset position found at mid *\/\u003Cbr \/\u003E            return mid;\u003Cbr \/\u003E        else\u003Cbr \/\u003E        if (arr[mid] \u0026gt; arr[size-1])\u003Cbr \/\u003E            \/* Offset may be on the right hand side, as arr[mid] is greater than the very last element in arr[] *\/\u003Cbr \/\u003E            return findOffset(arr, mid+1, high, size);\u003Cbr \/\u003E        else\u003Cbr \/\u003E            \/* Offset may be on the left hand side *\/\u003Cbr \/\u003E            return findOffset(arr, low, mid-1, size);\u003Cbr \/\u003E    }\u003Cbr \/\u003E\u003Cbr \/\u003E    return -1;    \/\/ No offset found in arr[]\u003Cbr \/\u003E}\u003Cbr \/\u003E\u003Cbr \/\u003E\/* Function for performing Binary Search to find item in the array *\/\u003Cbr \/\u003Eint binarySearch(int *arr, int low, int high, int item)\u003Cbr \/\u003E{\u003Cbr \/\u003E    int mid;\u003Cbr \/\u003E    if (low \u0026lt;= high)\u003Cbr \/\u003E    {\u003Cbr \/\u003E        mid = low + ((high - low) \/ 2);\u003Cbr \/\u003E\u003Cbr \/\u003E        if (arr[mid] == item)\u003Cbr \/\u003E            return mid;\u003Cbr \/\u003E        else\u003Cbr \/\u003E        if (arr[mid] \u0026gt; item)\u003Cbr \/\u003E            return binarySearch(arr, low, mid-1, item);\u003Cbr \/\u003E        else\u003Cbr \/\u003E            return binarySearch(arr, mid+1, high, item);\u003Cbr \/\u003E    }\u003Cbr \/\u003E\u003Cbr \/\u003E    return -1;\u003Cbr \/\u003E}\u003Cbr \/\u003E\u003Cbr \/\u003E\/* Main function *\/\u003Cbr \/\u003Eint main()\u003Cbr \/\u003E{\u003Cbr \/\u003E    int i, size, offset, item, index, *arr;\u003Cbr \/\u003E    printf(\"\\nEnter size of array: \\n\");\u003Cbr \/\u003E    scanf(\"%d\", \u0026size);\u003Cbr \/\u003E    arr = (int*)malloc(size * sizeof(int));\u003Cbr \/\u003E\u003Cbr \/\u003E    printf(\"\\nEnter elements in array: \\n\");\u003Cbr \/\u003E    for (i = 0; i \u0026lt; size; i++)\u003Cbr \/\u003E        scanf(\"%d\", \u0026arr[i]);\u003Cbr \/\u003E\u003Cbr \/\u003E    printf(\"\\nEnter search item: \\n\");\u003Cbr \/\u003E    scanf(\"%d\", \u0026item);\u003Cbr \/\u003E\u003Cbr \/\u003E    \/* Get the position of offset (rotation) *\/\u003Cbr \/\u003E    offset = findOffset(arr, 0, size-1, size);\u003Cbr \/\u003E\u003Cbr \/\u003E    \/* If the array was not rotated, use normal Binary Search *\/\u003Cbr \/\u003E    if (offset == -1)\u003Cbr \/\u003E    {\u003Cbr \/\u003E        index = binarySearch(arr, 0, size-1, item);\u003Cbr \/\u003E        (index != -1) ? printf(\"Item found at index  %d.\\n\", index) : printf(\"Item not found.\\n\");\u003Cbr \/\u003E    }\u003Cbr \/\u003E    \/* Otherwise the array was rotated, use Binary Search in left and right sub-arrays separately *\/\u003Cbr \/\u003E    else\u003Cbr \/\u003E    {\u003Cbr \/\u003E        \/* Search in the sub-array till the offset position *\/\u003Cbr \/\u003E        index = binarySearch(arr, 0, offset, item);\u003Cbr \/\u003E        if (index != -1)\u003Cbr \/\u003E            printf(\"Item found at index  %d.\\n\", index);\u003Cbr \/\u003E        else\u003Cbr \/\u003E        {\u003Cbr \/\u003E            \/* Search in the sub-array right of the offset position *\/\u003Cbr \/\u003E            index = binarySearch(arr, offset+1, size-1, item);\u003Cbr \/\u003E            (index != -1) ? printf(\"Item found at index  %d.\\n\", index) : printf(\"Item not found.\\n\");\u003Cbr \/\u003E        }\u003Cbr \/\u003E    }\u003Cbr \/\u003E\u003Cbr \/\u003E    return 0;\u003Cbr \/\u003E}\u003Cbr \/\u003E\u003C\/pre\u003E\u003C\/div\u003E"},"link":[{"rel":"replies","type":"application/atom+xml","href":"https:\/\/geekfactorial.blogspot.com\/feeds\/1159264033540602758\/comments\/default","title":"Post Comments"},{"rel":"replies","type":"text/html","href":"https:\/\/geekfactorial.blogspot.com\/2016\/08\/binary-search-in-sorted-and-shifted.html#comment-form","title":"1 Comments"},{"rel":"edit","type":"application/atom+xml","href":"https:\/\/www.blogger.com\/feeds\/4840603379647116080\/posts\/default\/1159264033540602758"},{"rel":"self","type":"application/atom+xml","href":"https:\/\/www.blogger.com\/feeds\/4840603379647116080\/posts\/default\/1159264033540602758"},{"rel":"alternate","type":"text/html","href":"https:\/\/geekfactorial.blogspot.com\/2016\/08\/binary-search-in-sorted-and-shifted.html","title":"Binary Search in sorted and shifted (rotated) array"}],"author":[{"name":{"$t":"Unknown"},"email":{"$t":"noreply@blogger.com"},"gd$image":{"rel":"http://schemas.google.com/g/2005#thumbnail","width":"16","height":"16","src":"https:\/\/img1.blogblog.com\/img\/b16-rounded.gif"}}],"thr$total":{"$t":"1"}},{"id":{"$t":"tag:blogger.com,1999:blog-4840603379647116080.post-7986692473249975233"},"published":{"$t":"2016-08-10T12:31:00.001+05:30"},"updated":{"$t":"2016-08-14T10:21:50.584+05:30"},"category":[{"scheme":"http://www.blogger.com/atom/ns#","term":"algorithms"},{"scheme":"http://www.blogger.com/atom/ns#","term":"divide and conquer"},{"scheme":"http://www.blogger.com/atom/ns#","term":"programming"}],"title":{"type":"text","$t":"There may be a bug hidden in your Binary Searches and Merge Sorts!"},"content":{"type":"html","$t":"\u003Cdiv dir=\"ltr\" style=\"text-align: left;\" trbidi=\"on\"\u003EYour implementation of the \u003Ca href=\"https:\/\/geekfactorial.blogspot.in\/2016\/08\/binary-search.html\"\u003EBinary Search\u003C\/a\u003E algorithm might be having a concealed bug in it! This Binary Search bug applies equally to Merge Sort and many other Divide and Conquer algorithms. If you have any code that implements one of these algorithms, better fix it now before it messes something up.\u003Cbr \/\u003E\u003Cbr \/\u003EHere is a generally seen Binary Search code (in Java):\u003Cbr \/\u003E\u003Cpre class=\"brush:java; code\"\u003Epublic static int binarySearch(int[] a, int item) {\u003Cbr \/\u003E    int low = 0;\u003Cbr \/\u003E    int high = a.length - 1;\u003Cbr \/\u003E\u003Cbr \/\u003E    while(low \u0026lt;= high) {\u003Cbr \/\u003E        int mid = (low + high) \/ 2;\u003Cbr \/\u003E\u003Cbr \/\u003E        if(a[mid] == item)\u003Cbr \/\u003E            return mid;        \/\/ Key found\u003Cbr \/\u003E        else if (a[mid] \u0026lt; key)\u003Cbr \/\u003E            low = mid + 1\u003Cbr \/\u003E        else\u003Cbr \/\u003E            high = mid - 1;\u003Cbr \/\u003E    }\u003Cbr \/\u003E\u003Cbr \/\u003E    return -(low + 1);         \/\/ Key not found\u003Cbr \/\u003E}\u003Cbr \/\u003E\u003C\/pre\u003E\u003Cbr \/\u003EThe bug is in this line:\u003Cbr \/\u003E\u003Cpre class=\"brush:java; code\"\u003Eint mid = (low + high) \/ 2;    \/\/ Problem!\u003Cbr \/\u003E\u003C\/pre\u003EWhat the above line does is that it sets mid to the average of low and high, truncated down to the nearest integer. At a glance, nothing seems to be wrong in that, but it fails for large values of the int variables low and high. Specifically, it fails if the sum of low and high is greater than the maximum positive int value (2\u003Csup\u003E31\u003C\/sup\u003E - 1). The sum overflows to a negative value and the value stays negative when divided by two, causing the array to go out of bounds. In Java, it throws \u003Ci\u003EArrayIndexOutOfBoundsException\u003C\/i\u003E while in C it causes unpredictable results. This bug can manifest itself for arrays whose length (in elements) is 2\u003Csup\u003E30\u003C\/sup\u003E or greater (roughly a billion elements).\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cdiv class=\"separator\" style=\"clear: both; text-align: center;\"\u003E\u003Ca href=\"https:\/\/4.bp.blogspot.com\/-8TPr6SKxMJM\/V6rhv4GtC8I\/AAAAAAAAAfU\/0QNpMeucmcEMFVn8EjfVKxz6LJeLkPnyQCLcB\/s1600\/binary-search-bug.jpg\" imageanchor=\"1\" style=\"margin-left: 1em; margin-right: 1em;\"\u003E\u003Cimg border=\"0\" height=\"384\" src=\"https:\/\/4.bp.blogspot.com\/-8TPr6SKxMJM\/V6rhv4GtC8I\/AAAAAAAAAfU\/0QNpMeucmcEMFVn8EjfVKxz6LJeLkPnyQCLcB\/s640\/binary-search-bug.jpg\" width=\"640\" \/\u003E\u003C\/a\u003E\u003C\/div\u003E\u003Cbr \/\u003ESo now we want to fix it, right? Here are some ideas to correct the line:\u003Cbr \/\u003E\u003Cpre class=\"brush:java; code\"\u003Eint mid = low + ((high - low) \/ 2);\u003Cbr \/\u003E\u003C\/pre\u003E\u003Cbr \/\u003EAlso note that right shifting a number by one bit is equivalent to dividing it by 2. We can utilize the unsigned right shift operator (\u0026gt;\u0026gt;\u0026gt;) available in Java. The \u0026gt;\u0026gt;\u0026gt; operator lets you treat int and long as 32-bit and 64-bit unsigned integral types (Java does not provide unsigned int and unsigned long data types).\u003Cbr \/\u003E\u003Cpre class=\"brush:java; code\"\u003Eint mid = (low + high) \u0026gt;\u0026gt;\u0026gt; 1;\u003Cbr \/\u003E\u003C\/pre\u003E\u003Cbr \/\u003EIn C and C++, where you don't have the \u0026gt;\u0026gt;\u0026gt; operator, you can do this:\u003Cbr \/\u003E\u003Cpre class=\"brush:cpp; code\"\u003Eint mid = ((unsigned int)low + (unsigned int)high)) \u0026gt;\u0026gt; 1;\u003Cbr \/\u003E\u003C\/pre\u003E\u003Cbr \/\u003E\u003Cb\u003ENote:\u003C\/b\u003E\u003Cbr \/\u003E\u003Cul style=\"text-align: left;\"\u003E\u003Cli\u003EYou should always check array algorithms for possible overflow.\u003C\/li\u003E\u003Cli\u003EElements that are meant to store array indexes should be taken as unsigned int.\u003C\/li\u003E\u003C\/ul\u003E(Credit to \u003Ca href=\"https:\/\/research.googleblog.com\/2006\/06\/extra-extra-read-all-about-it-nearly.html\" target=\"_blank\"\u003Ethis article on Google Research Blog\u003C\/a\u003E for the above concepts.)\u003Cbr \/\u003E\u003C\/div\u003E"},"link":[{"rel":"replies","type":"application/atom+xml","href":"https:\/\/geekfactorial.blogspot.com\/feeds\/7986692473249975233\/comments\/default","title":"Post Comments"},{"rel":"replies","type":"text/html","href":"https:\/\/geekfactorial.blogspot.com\/2016\/08\/the-hidden-bug-in-binary-searches-merge-sorts-and-other-divide-and-conquer-algorithms.html#comment-form","title":"0 Comments"},{"rel":"edit","type":"application/atom+xml","href":"https:\/\/www.blogger.com\/feeds\/4840603379647116080\/posts\/default\/7986692473249975233"},{"rel":"self","type":"application/atom+xml","href":"https:\/\/www.blogger.com\/feeds\/4840603379647116080\/posts\/default\/7986692473249975233"},{"rel":"alternate","type":"text/html","href":"https:\/\/geekfactorial.blogspot.com\/2016\/08\/the-hidden-bug-in-binary-searches-merge-sorts-and-other-divide-and-conquer-algorithms.html","title":"There may be a bug hidden in your Binary Searches and Merge Sorts!"}],"author":[{"name":{"$t":"Unknown"},"email":{"$t":"noreply@blogger.com"},"gd$image":{"rel":"http://schemas.google.com/g/2005#thumbnail","width":"16","height":"16","src":"https:\/\/img1.blogblog.com\/img\/b16-rounded.gif"}}],"media$thumbnail":{"xmlns$media":"http://search.yahoo.com/mrss/","url":"https:\/\/4.bp.blogspot.com\/-8TPr6SKxMJM\/V6rhv4GtC8I\/AAAAAAAAAfU\/0QNpMeucmcEMFVn8EjfVKxz6LJeLkPnyQCLcB\/s72-c\/binary-search-bug.jpg","height":"72","width":"72"},"thr$total":{"$t":"0"}},{"id":{"$t":"tag:blogger.com,1999:blog-4840603379647116080.post-7530257327221074963"},"published":{"$t":"2016-08-09T20:01:00.000+05:30"},"updated":{"$t":"2016-08-10T15:31:15.214+05:30"},"category":[{"scheme":"http://www.blogger.com/atom/ns#","term":"algorithms"},{"scheme":"http://www.blogger.com/atom/ns#","term":"c"},{"scheme":"http://www.blogger.com/atom/ns#","term":"divide and conquer"},{"scheme":"http://www.blogger.com/atom/ns#","term":"programming"}],"title":{"type":"text","$t":"Binary Search"},"content":{"type":"html","$t":"\u003Cdiv dir=\"ltr\" style=\"text-align: left;\" trbidi=\"on\"\u003EBinary search, also known logarithmic search or half-interval search, is a \"Divide and Conquer\" search algorithm that finds the position of a target value within a sorted array in run-time complexity of Ο(log n). It is one of the fundamental algorithms in Computer Science. For this algorithm to work properly \u003Ci\u003Ethe data collection should be in sorted form\u003C\/i\u003E.\u003Cbr \/\u003E\u003Cbr \/\u003EBinary search searches for a particular item by comparing it with the middle element of the array. If match occurs, then index of the middle element is returned. If the item is smaller than the middle element, then it is searched in the left sub-array of the middle element, otherwise the item is searched in the right sub-array of the middle element. This process continues on the sub-arrays as well, till the item is found or the size of sub-array reduces to zero.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cdiv class=\"separator\" style=\"clear: both; text-align: center;\"\u003E\u003Ca href=\"https:\/\/3.bp.blogspot.com\/-HqEKEPf4CAg\/V6nnx3ffX2I\/AAAAAAAAAfE\/2hiHLuoNsnshtQ3z_glI5KZ9VKMuz4NhACLcB\/s1600\/Binary_search_in_an_array.png\" imageanchor=\"1\" style=\"margin-left: 1em; margin-right: 1em;\"\u003E\u003Cimg border=\"0\" height=\"255\" src=\"https:\/\/3.bp.blogspot.com\/-HqEKEPf4CAg\/V6nnx3ffX2I\/AAAAAAAAAfE\/2hiHLuoNsnshtQ3z_glI5KZ9VKMuz4NhACLcB\/s400\/Binary_search_in_an_array.png\" width=\"400\" \/\u003E\u003C\/a\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: center;\"\u003E(Image from \u003Ca href=\"https:\/\/en.wikipedia.org\/wiki\/File:Binary_search_into_array.png\" target=\"_blank\"\u003EWikipedia\u003C\/a\u003E)\u003C\/div\u003E\u003Cbr \/\u003E\u003Cb\u003ETime Complexity:\u003C\/b\u003E O(log n)\u003Cbr \/\u003E\u003Cb\u003ESpace Complexity:\u003C\/b\u003E O(1) in iterative implementation and O(log n) in recursive implementation (considering the recursion call stack space).\u003Cbr \/\u003E\u003Cbr \/\u003EBoth iterative and recursive implementations of Binary Search are shown here:\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cb\u003E1. Iterative Binary Search:\u003C\/b\u003E\u003Cbr \/\u003E\u003Cpre class=\"brush:cpp; code\"\u003Eint binarySearch(int *A, int size, int item)\u003Cbr \/\u003E{\u003Cbr \/\u003E    int start = 0, end = (size - 1), mid;\u003Cbr \/\u003E\u003Cbr \/\u003E    while(start \u0026lt;= end)\u003Cbr \/\u003E    {\u003Cbr \/\u003E        mid = (start + end) \/ 2;\u003Cbr \/\u003E\u003Cbr \/\u003E        if(A[mid] == item)\u003Cbr \/\u003E            return mid;            \/\/ Item found at index mid\u003Cbr \/\u003E\u003Cbr \/\u003E        else if(A[mid] \u0026gt; item)\u003Cbr \/\u003E            end = mid - 1;         \/\/ Item may be on the left sub-array\u003Cbr \/\u003E\u003Cbr \/\u003E        else\u003Cbr \/\u003E            start = mid + 1;       \/\/ Item may be on the right sub-array\u003Cbr \/\u003E    }\u003Cbr \/\u003E\u003Cbr \/\u003E    return -1;    \/\/ Not found\u003Cbr \/\u003E}\u003Cbr \/\u003E\u003C\/pre\u003E\u003Cbr \/\u003E\u003Cb\u003E2. Recursive Binary Search:\u003C\/b\u003E\u003Cbr \/\u003E\u003Cpre class=\"brush:cpp; code\"\u003Eint binarySearch(int *A, int start, int end, int item)\u003Cbr \/\u003E{\u003Cbr \/\u003E    int mid;\u003Cbr \/\u003E\u003Cbr \/\u003E    if(start \u0026lt;= end)\u003Cbr \/\u003E    {\u003Cbr \/\u003E        mid = (start + end) \/ 2;\u003Cbr \/\u003E\u003Cbr \/\u003E        if(A[mid] == item)\u003Cbr \/\u003E            return mid;\u003Cbr \/\u003E\u003Cbr \/\u003E        else if(A[mid] \u0026gt; item)\u003Cbr \/\u003E            return binarySearch(A, start, mid-1, item);\u003Cbr \/\u003E\u003Cbr \/\u003E        else\u003Cbr \/\u003E            return binarySearch(A, mid+1, end, item);\u003Cbr \/\u003E    }\u003Cbr \/\u003E\u003Cbr \/\u003E    return -1;\u003Cbr \/\u003E}\u003Cbr \/\u003E\u003C\/pre\u003E\u003Cbr \/\u003E\u003Cb\u003ENote:\u003C\/b\u003E The above Binary Search algorithms may fail in some cases. See this post for detail: \u003Ca href=\"https:\/\/geekfactorial.blogspot.in\/2016\/08\/the-hidden-bug-in-binary-searches-merge-sorts-and-other-divide-and-conquer-algorithms.html\"\u003EThere may be a bug hidden in your Binary Searches and Merge Sorts!\u003C\/a\u003E\u003Cbr \/\u003E\u003C\/div\u003E"},"link":[{"rel":"replies","type":"application/atom+xml","href":"https:\/\/geekfactorial.blogspot.com\/feeds\/7530257327221074963\/comments\/default","title":"Post Comments"},{"rel":"replies","type":"text/html","href":"https:\/\/geekfactorial.blogspot.com\/2016\/08\/binary-search.html#comment-form","title":"0 Comments"},{"rel":"edit","type":"application/atom+xml","href":"https:\/\/www.blogger.com\/feeds\/4840603379647116080\/posts\/default\/7530257327221074963"},{"rel":"self","type":"application/atom+xml","href":"https:\/\/www.blogger.com\/feeds\/4840603379647116080\/posts\/default\/7530257327221074963"},{"rel":"alternate","type":"text/html","href":"https:\/\/geekfactorial.blogspot.com\/2016\/08\/binary-search.html","title":"Binary Search"}],"author":[{"name":{"$t":"Unknown"},"email":{"$t":"noreply@blogger.com"},"gd$image":{"rel":"http://schemas.google.com/g/2005#thumbnail","width":"16","height":"16","src":"https:\/\/img1.blogblog.com\/img\/b16-rounded.gif"}}],"media$thumbnail":{"xmlns$media":"http://search.yahoo.com/mrss/","url":"https:\/\/3.bp.blogspot.com\/-HqEKEPf4CAg\/V6nnx3ffX2I\/AAAAAAAAAfE\/2hiHLuoNsnshtQ3z_glI5KZ9VKMuz4NhACLcB\/s72-c\/Binary_search_in_an_array.png","height":"72","width":"72"},"thr$total":{"$t":"0"}},{"id":{"$t":"tag:blogger.com,1999:blog-4840603379647116080.post-2818671991020723459"},"published":{"$t":"2016-08-09T11:27:00.000+05:30"},"updated":{"$t":"2016-08-09T20:06:14.071+05:30"},"category":[{"scheme":"http://www.blogger.com/atom/ns#","term":"algorithms"},{"scheme":"http://www.blogger.com/atom/ns#","term":"c"},{"scheme":"http://www.blogger.com/atom/ns#","term":"divide and conquer"},{"scheme":"http://www.blogger.com/atom/ns#","term":"programming"}],"title":{"type":"text","$t":"Randomized Quick Sort algorithm - O(n log n) worst case complexity"},"content":{"type":"html","$t":"\u003Cdiv dir=\"ltr\" style=\"text-align: left;\" trbidi=\"on\"\u003EThe worst case time complexity of a \u003Ca href=\"https:\/\/geekfactorial.blogspot.in\/2016\/08\/quick-sort.html\"\u003Etypical implementation of Quick Sort\u003C\/a\u003E is O(n\u003Csup\u003E2\u003C\/sup\u003E). The worst case occurs when the picked pivot is always an extreme (smallest or largest) element, which happens when the input array is either sorted or reversely sorted and either first or last element is picked as pivot.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cb\u003ERandomized Quick Sort algorithm (with random pivot):\u003C\/b\u003E\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cdiv class=\"separator\" style=\"clear: both; text-align: center;\"\u003E\u003Ca href=\"https:\/\/1.bp.blogspot.com\/-jJxIGqYzFh4\/V6lt2AgH3JI\/AAAAAAAAAe0\/6UentQ5qP34UYBkTaKO8aWntI33XTICdwCLcB\/s1600\/randomized-pivot-in-quicksort.jpg\" imageanchor=\"1\" style=\"margin-left: 1em; margin-right: 1em;\"\u003E\u003Cimg border=\"0\" height=\"300\" src=\"https:\/\/1.bp.blogspot.com\/-jJxIGqYzFh4\/V6lt2AgH3JI\/AAAAAAAAAe0\/6UentQ5qP34UYBkTaKO8aWntI33XTICdwCLcB\/s400\/randomized-pivot-in-quicksort.jpg\" width=\"400\" \/\u003E\u003C\/a\u003E\u003C\/div\u003E\u003Cbr \/\u003EIn the randomized version of Quick sort we impose a distribution on input by picking the pivot element randomly. Randomized Quick Sort works well even when the array is sorted\/reversely sorted and the complexity is more towards O(n log n). (Yet, there is still a possibility that the randomly picked element is always an extreme.)\u003Cbr \/\u003E\u003Cbr \/\u003EHere, we will pick a random pivot position with the help of \u003Ci\u003Erand()\u003C\/i\u003E function (defined in \u003Ci\u003Estdlib.h\u003C\/i\u003E header file). Then we can swap pivot element with the element at the \u003Ci\u003ELeft\u003C\/i\u003E position (or the \u003Ci\u003ERight\u003C\/i\u003E position in some implementations) and Quick Sort the array.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cpre class=\"brush:cpp; code\"\u003Evoid swap(int *A, int x, int y) {\u003Cbr \/\u003E    int temp;\u003Cbr \/\u003E    temp = A[x];\u003Cbr \/\u003E    A[x] = A[y];\u003Cbr \/\u003E    A[y] = temp;\u003Cbr \/\u003E}\u003Cbr \/\u003E\u003Cbr \/\u003Eint getPivot(int Left, int Right) {\u003Cbr \/\u003E    return ( rand() % (Right - Left + 1) ) + Left;\u003Cbr \/\u003E}\u003Cbr \/\u003E\u003Cbr \/\u003Evoid quickSort(int *A, int Left, int Right) {\u003Cbr \/\u003E    if(Left \u0026gt; Right)\u003Cbr \/\u003E        return;\u003Cbr \/\u003E    \u003Cbr \/\u003E    int i, pos, pivot;\u003Cbr \/\u003E\u003Cbr \/\u003E    \/\/ Choosing pivot element randomly:\u003Cbr \/\u003E\u003Cbr \/\u003E    pivot = getPivot(Left, Right);  \/\/ Get a random pivot\u003Cbr \/\u003E    swap(A, Left, pivot);           \/\/ Take A[pivot] to Left index and then do Quick Sort\u003Cbr \/\u003E\u003Cbr \/\u003E    \/\/ Quick Sort the array:\u003Cbr \/\u003E\u003Cbr \/\u003E    pos = Left;\u003Cbr \/\u003E        \u003Cbr \/\u003E    for(i = Left+1; i \u0026lt;= Right; i++)\u003Cbr \/\u003E        if(A[i] \u0026lt; A[Left])\u003Cbr \/\u003E            swap(A, ++pos, i);\u003Cbr \/\u003E\u003Cbr \/\u003E    swap(A, Left, pos);  \/\/ By now, pos must be at proper position for A[Left].\u003Cbr \/\u003E                         \/\/ So we swap A[Left] with A[pos]\u003Cbr \/\u003E\u003Cbr \/\u003E    quickSort(A, Left, pos-1);     \/\/ Sort left sub-list\u003Cbr \/\u003E    quickSort(A, pos+1, Right);    \/\/ Sort right sub-list\u003Cbr \/\u003E}\u003Cbr \/\u003E\u003C\/pre\u003E\u003C\/div\u003E"},"link":[{"rel":"replies","type":"application/atom+xml","href":"https:\/\/geekfactorial.blogspot.com\/feeds\/2818671991020723459\/comments\/default","title":"Post Comments"},{"rel":"replies","type":"text/html","href":"https:\/\/geekfactorial.blogspot.com\/2016\/08\/randomized-quick-sort-algorithm.html#comment-form","title":"0 Comments"},{"rel":"edit","type":"application/atom+xml","href":"https:\/\/www.blogger.com\/feeds\/4840603379647116080\/posts\/default\/2818671991020723459"},{"rel":"self","type":"application/atom+xml","href":"https:\/\/www.blogger.com\/feeds\/4840603379647116080\/posts\/default\/2818671991020723459"},{"rel":"alternate","type":"text/html","href":"https:\/\/geekfactorial.blogspot.com\/2016\/08\/randomized-quick-sort-algorithm.html","title":"Randomized Quick Sort algorithm - O(n log n) worst case complexity"}],"author":[{"name":{"$t":"Unknown"},"email":{"$t":"noreply@blogger.com"},"gd$image":{"rel":"http://schemas.google.com/g/2005#thumbnail","width":"16","height":"16","src":"https:\/\/img1.blogblog.com\/img\/b16-rounded.gif"}}],"media$thumbnail":{"xmlns$media":"http://search.yahoo.com/mrss/","url":"https:\/\/1.bp.blogspot.com\/-jJxIGqYzFh4\/V6lt2AgH3JI\/AAAAAAAAAe0\/6UentQ5qP34UYBkTaKO8aWntI33XTICdwCLcB\/s72-c\/randomized-pivot-in-quicksort.jpg","height":"72","width":"72"},"thr$total":{"$t":"0"}},{"id":{"$t":"tag:blogger.com,1999:blog-4840603379647116080.post-4976284223491022802"},"published":{"$t":"2016-08-08T22:20:00.001+05:30"},"updated":{"$t":"2016-08-09T20:07:18.956+05:30"},"category":[{"scheme":"http://www.blogger.com/atom/ns#","term":"algorithms"},{"scheme":"http://www.blogger.com/atom/ns#","term":"c"},{"scheme":"http://www.blogger.com/atom/ns#","term":"divide and conquer"},{"scheme":"http://www.blogger.com/atom/ns#","term":"programming"}],"title":{"type":"text","$t":"Quick Sort"},"content":{"type":"html","$t":"\u003Cdiv dir=\"ltr\" style=\"text-align: left;\" trbidi=\"on\"\u003EQuick Sort is a Divide and Conquer sorting algorithm. It picks an element as pivot element and partitions the given array around the picked pivot such that pivot element comes at its proper sorted position and the elements smaller than pivot element are on its left hand side and the elements larger than pivot element are on its right hand side. Now it recursively sorts the left sub-array and right sub-array of pivot element in the same manner till no further partitioning can be done.\u003Cbr \/\u003E\u003Cbr \/\u003EThere are many different versions of Quick Sort that pick pivot in different ways, like:\u003Cbr \/\u003E\u003Col style=\"text-align: left;\"\u003E\u003Cli\u003EAlways pick first element as pivot. (implemented below)\u003C\/li\u003E\u003Cli\u003EAlways pick last element as pivot.\u003C\/li\u003E\u003Cli\u003EPick a random element as pivot.\u003C\/li\u003E\u003Cli\u003EPick median as pivot.\u003C\/li\u003E\u003C\/ol\u003EThe key process in Quick Sort is partitioning. The target of partitions is that given an array and an element x of array as pivot, put x at its correct position (as that in sorted array) and put all elements smaller than x before x and all elements greater than x after x in the array. All this should be done in linear time.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cdiv class=\"separator\" style=\"clear: both; text-align: center;\"\u003E\u003Ca href=\"https:\/\/4.bp.blogspot.com\/--hxU3SPfamA\/V6i0VV5a6PI\/AAAAAAAAAeQ\/HLykQcaX_AIKh1oAljCxlMuJmhAcqqa9ACLcB\/s1600\/quick-sort-working.png\" imageanchor=\"1\" style=\"margin-left: 1em; margin-right: 1em;\"\u003E\u003Cimg border=\"0\" height=\"193\" src=\"https:\/\/4.bp.blogspot.com\/--hxU3SPfamA\/V6i0VV5a6PI\/AAAAAAAAAeQ\/HLykQcaX_AIKh1oAljCxlMuJmhAcqqa9ACLcB\/s320\/quick-sort-working.png\" width=\"320\" \/\u003E\u003C\/a\u003E\u003C\/div\u003E\u003Cbr \/\u003E\u003Cb\u003ETime complexity:\u003C\/b\u003E O(n log n) in average case, O(n\u003Csup\u003E2\u003C\/sup\u003E) in worst case (Here worst case is when array is sorted or reversely sorted.)\u003Cbr \/\u003E\u003Cb\u003ESpace complexity:\u003C\/b\u003E O(log n) in average case, up to O(n) in worst case (This extra space may come from the call stack.)\u003Cbr \/\u003E\u003Cbr \/\u003EAlthough the worst case time complexity of Quick Sort is O(n\u003Csup\u003E2\u003C\/sup\u003E) which is more than many other sorting algorithms like Merge Sort and Heap Sort, Quick Sort is faster in practice because its inner loop can be efficiently implemented on most architectures, and in most real-world data. The algorithm can be modified to make it much more efficient. For example, \u003Ca href=\"https:\/\/geekfactorial.blogspot.in\/2016\/08\/randomized-quick-sort-algorithm.html\"\u003ERandomized Quick Sort\u003C\/a\u003E shows O(n log n) complexity even for worst case, as it picks pivot randomly.\u003Cbr \/\u003E\u003Cbr \/\u003EQuick Sort can be implemented in different ways by changing the choice of pivot, so that the worst case rarely occurs for a given type of data. However, Merge Sort is generally considered better when data is huge and stored in external storage.\u003Cbr \/\u003E\u003Cbr \/\u003EBelow is one of the many ways to implement Quick Sort:\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cpre class=\"brush:cpp; code\"\u003E#include \u0026lt;stdio.h\u0026gt;\u003Cbr \/\u003E\u003Cbr \/\u003Evoid swap(int *x, int *y)\u003Cbr \/\u003E{\u003Cbr \/\u003E    int temp = *x;\u003Cbr \/\u003E    *x       = *y;\u003Cbr \/\u003E    *y       = temp;\u003Cbr \/\u003E}\u003Cbr \/\u003E\u003Cbr \/\u003Evoid quickSort(int *A, int Left, int Right)\u003Cbr \/\u003E{\u003Cbr \/\u003E    int i, pos;\u003Cbr \/\u003E    if(Left \u0026lt; Right)\u003Cbr \/\u003E    {\u003Cbr \/\u003E        pos = Left;\u003Cbr \/\u003E        for(i = Left+1; i \u0026lt;= Right; i++)\u003Cbr \/\u003E            if(A[i] \u0026lt; A[Left])\u003Cbr \/\u003E                swap(\u0026amp;A[++pos], \u0026amp;A[i]);   \/\/ When order is mismatched, increment pos and swap A[pos] with A[i]\u003Cbr \/\u003E\u003Cbr \/\u003E        swap(\u0026amp;A[Left], \u0026amp;A[pos]);   \/\/ By now, pos is at proper position for A[Left]. Actually Left acts as pivot element here! Now swap A[Left] with A[pos]\u003Cbr \/\u003E\u003Cbr \/\u003E        quickSort(A, Left, pos-1);     \/\/ Sort left sub-list\u003Cbr \/\u003E        quickSort(A, pos+1, Right);    \/\/ Sort right sub-list\u003Cbr \/\u003E    }\u003Cbr \/\u003E}\u003Cbr \/\u003E\u003Cbr \/\u003Eint main()\u003Cbr \/\u003E{\u003Cbr \/\u003E    int i, size;\u003Cbr \/\u003E    printf(\"\\n\\nEnter size of array: \");\u003Cbr \/\u003E    scanf(\"%d\", \u0026amp;size);\u003Cbr \/\u003E    int A[size];\u003Cbr \/\u003E\u003Cbr \/\u003E    printf(\"\\n\\nEnter %d elements: \\n\", size);\u003Cbr \/\u003E    for(i = 0; i \u0026lt; size; i++)\u003Cbr \/\u003E        scanf(\"%d\", \u0026amp;A[i]);\u003Cbr \/\u003E \u003Cbr \/\u003E    quickSort(A, 0, size-1);\u003Cbr \/\u003E\u003Cbr \/\u003E    printf(\"\\n\\nQuick sorted: \");\u003Cbr \/\u003E    for(i = 0; i \u0026lt; size; i++)\u003Cbr \/\u003E        printf(\"%d \", A[i]);\u003Cbr \/\u003E \u003Cbr \/\u003E    return 0;\u003Cbr \/\u003E}\u003Cbr \/\u003E\u003C\/pre\u003E\u003C\/div\u003E"},"link":[{"rel":"replies","type":"application/atom+xml","href":"https:\/\/geekfactorial.blogspot.com\/feeds\/4976284223491022802\/comments\/default","title":"Post Comments"},{"rel":"replies","type":"text/html","href":"https:\/\/geekfactorial.blogspot.com\/2016\/08\/quick-sort.html#comment-form","title":"2 Comments"},{"rel":"edit","type":"application/atom+xml","href":"https:\/\/www.blogger.com\/feeds\/4840603379647116080\/posts\/default\/4976284223491022802"},{"rel":"self","type":"application/atom+xml","href":"https:\/\/www.blogger.com\/feeds\/4840603379647116080\/posts\/default\/4976284223491022802"},{"rel":"alternate","type":"text/html","href":"https:\/\/geekfactorial.blogspot.com\/2016\/08\/quick-sort.html","title":"Quick Sort"}],"author":[{"name":{"$t":"Unknown"},"email":{"$t":"noreply@blogger.com"},"gd$image":{"rel":"http://schemas.google.com/g/2005#thumbnail","width":"16","height":"16","src":"https:\/\/img1.blogblog.com\/img\/b16-rounded.gif"}}],"media$thumbnail":{"xmlns$media":"http://search.yahoo.com/mrss/","url":"https:\/\/4.bp.blogspot.com\/--hxU3SPfamA\/V6i0VV5a6PI\/AAAAAAAAAeQ\/HLykQcaX_AIKh1oAljCxlMuJmhAcqqa9ACLcB\/s72-c\/quick-sort-working.png","height":"72","width":"72"},"thr$total":{"$t":"2"}},{"id":{"$t":"tag:blogger.com,1999:blog-4840603379647116080.post-4494505227464051338"},"published":{"$t":"2016-08-08T21:37:00.000+05:30"},"updated":{"$t":"2016-08-13T12:19:56.889+05:30"},"category":[{"scheme":"http://www.blogger.com/atom/ns#","term":"algorithms"},{"scheme":"http://www.blogger.com/atom/ns#","term":"c"},{"scheme":"http://www.blogger.com/atom/ns#","term":"divide and conquer"},{"scheme":"http://www.blogger.com/atom/ns#","term":"programming"}],"title":{"type":"text","$t":"Merge Sort"},"content":{"type":"html","$t":"\u003Cdiv dir=\"ltr\" style=\"text-align: left;\" trbidi=\"on\"\u003EMerge sort is a \"Divide and Conquer\" algorithm which divides input array into two halves, calls itself for the two halves and then merges the two sorted halves. Basically, merge sort merges two sorted sub-arrays into one sorted array. For example: Let array A[] = {4, 5, 8, 9} and array B[] = {1, 2, 6, 10}, then the resulting array C[] = {1, 2, 4, 5, 6, 8, 9, 10}.\u003Cbr \/\u003E\u003Cbr \/\u003EMerge sort is shown below for merging two separate sorted arrays into one sorted array, and then for merge-sorting a given unsorted array with help of recursion.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cb\u003E1. Merging two sorted arrays into one sorted array:\u003C\/b\u003E\u003Cbr \/\u003EThe idea is to place index variables i and j at start of the two arrays A[] and B[] respectively. Now compare the corresponding elements of the two arrays, copy the smaller element into the result array C[] and increment that index. Also, when one of the arrays is completely exhausted, just copy the remaining elements from the other array into the result.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cpre class=\"brush:cpp; code\"\u003Evoid mergeSort(int *A, int *B, int *C, int sizeA, int sizeB, int sizeC)\u003Cbr \/\u003E{\u003Cbr \/\u003E    int a = 0, b = 0, c = 0;\u003Cbr \/\u003E    \u003Cbr \/\u003E    while(c \u0026lt; sizeC)\u003Cbr \/\u003E    {   \u003Cbr \/\u003E        if(a \u0026gt;= sizeA)          C[c++] = B[b++];    \/\/ Array A[] was exhausted\u003Cbr \/\u003E        else if(b \u0026gt;= sizeB)     C[c++] = A[a++];    \/\/ Array B[] was exhausted\u003Cbr \/\u003E        else if(A[a] \u0026lt; B[b])    C[c++] = A[a++];\u003Cbr \/\u003E        else                    C[c++] = B[b++];\u003Cbr \/\u003E    }\u003Cbr \/\u003E}\u003Cbr \/\u003E\u003C\/pre\u003E\u003Cbr \/\u003E\u003Cb\u003E2. Merge sort a given array with help of recursion:\u003C\/b\u003E\u003Cbr \/\u003ENow we know that we need two sorted arrays and we can merge sort them. Given an unsorted array, we can keep on splitting the array into two halved (sub-arrays) until size of sub-arrays reaches one. Now we can merge sort the sub arrays back to the actual array of given size, but in sorted order. The function \u003Ci\u003EmergeSortRecursive()\u003C\/i\u003E is used to part the array into sub-arrays recursively until single elements are reached. The \u003Ci\u003Emerge()\u003C\/i\u003E function is used for merging two halves. This function \u003Ci\u003Emerge(A, left, mid, right)\u003C\/i\u003E assumes that sub-arrays A[left..mid] and A[mid+1..right] are sorted and merges the two sorted sub-arrays into one.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cb\u003ETime complexity:\u003C\/b\u003E O(n log n)\u003Cbr \/\u003E\u003Cb\u003ESpace complexity:\u003C\/b\u003E O(n) (For taking an auxiliary array.)\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cpre class=\"brush:cpp; code\"\u003E#include \u0026lt;stdio.h\u0026gt;\u003Cbr \/\u003E\u003Cbr \/\u003Evoid merge(int *A, int left, int mid, int right)    \/\/ For merge-sorting the array partitions A[left to mid] and A[mid+1 to right]\u003Cbr \/\u003E{\u003Cbr \/\u003E    int B[right];\u003Cbr \/\u003E    int i = left, j = mid+1, k;\u003Cbr \/\u003E\u003Cbr \/\u003E    for(k = left; k \u0026lt;= right; k++)\u003Cbr \/\u003E    {\u003Cbr \/\u003E        if(i \u0026gt; mid)               B[k] = A[j++];    \/\/ Left array was exhausted. Copy right sub-array directly\u003Cbr \/\u003E        else if(j \u0026gt; right)        B[k] = A[i++];    \/\/ Right array was exhausted. Copy left sub-array directly\u003Cbr \/\u003E        else if(A[i] \u0026lt; A[j])      B[k] = A[i++];\u003Cbr \/\u003E        else                      B[k] = A[j++];\u003Cbr \/\u003E    }\u003Cbr \/\u003E\u003Cbr \/\u003E    for(k = left; k \u0026lt;= right; k++)\u003Cbr \/\u003E        A[k] = B[k];\u003Cbr \/\u003E}\u003Cbr \/\u003E\u003Cbr \/\u003Evoid mergeSortRecursive(int *A, int left, int right)    \/\/ For partitioning array recursively [in O(log n)] and then merge-sorting the 2 parts [in O(n)] via merge() function\u003Cbr \/\u003E{\u003Cbr \/\u003E    int mid;\u003Cbr \/\u003E\u003Cbr \/\u003E    if(left \u0026lt; right)\u003Cbr \/\u003E    {\u003Cbr \/\u003E        mid = (left + right) \/ 2;\u003Cbr \/\u003E        mergeSortRecursive(A, left, mid);       \/\/ Partition\u003Cbr \/\u003E        mergeSortRecursive(A, mid+1, right);    \/\/ Partition\u003Cbr \/\u003E\u003Cbr \/\u003E        merge(A, left, mid, right);             \/\/ Merge sort\u003Cbr \/\u003E    }\u003Cbr \/\u003E}\u003Cbr \/\u003E\u003Cbr \/\u003Eint main()\u003Cbr \/\u003E{\u003Cbr \/\u003E    int i, size;\u003Cbr \/\u003E    printf(\"\\n\\nEnter size of array: \");\u003Cbr \/\u003E    scanf(\"%d\", \u0026amp;size);\u003Cbr \/\u003E    int A[size];\u003Cbr \/\u003E\u003Cbr \/\u003E    printf(\"\\n\\nEnter %d elements: \\n\", size);\u003Cbr \/\u003E    for(i = 0; i \u0026lt; size; i++)\u003Cbr \/\u003E        scanf(\"%d\", \u0026amp;A[i]);\u003Cbr \/\u003E\u003Cbr \/\u003E    mergeSortRecursive(A, 0, size-1);\u003Cbr \/\u003E\u003Cbr \/\u003E    printf(\"\\n\\nMerge sorted: \");\u003Cbr \/\u003E    for(i = 0; i \u0026lt; size; i++)\u003Cbr \/\u003E        printf(\" %d \", A[i]);\u003Cbr \/\u003E\u003Cbr \/\u003E    return 0;\u003Cbr \/\u003E}\u003Cbr \/\u003E\u003C\/pre\u003E\u003Cbr \/\u003EHere is a diagram that tries to explain what is happening in recursive merge sort (taken from \u003Ca href=\"https:\/\/en.wikipedia.org\/wiki\/File:Merge_sort_algorithm_diagram.svg\" target=\"_blank\"\u003EWikipedia\u003C\/a\u003E):\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cdiv class=\"separator\" style=\"clear: both;\"\u003E\u003Ca href=\"https:\/\/2.bp.blogspot.com\/-k3w6HykFvlo\/V6iwsQrya4I\/AAAAAAAAAeE\/jhm4v2Pd3esgY6LhV4uviYJnX4bO79q0QCLcB\/s1600\/Merge_sort_algorithm_diagram.png\" imageanchor=\"1\" style=\"margin-left: 1em; margin-right: 1em;\"\u003E\u003Cimg border=\"0\" height=\"383\" src=\"https:\/\/2.bp.blogspot.com\/-k3w6HykFvlo\/V6iwsQrya4I\/AAAAAAAAAeE\/jhm4v2Pd3esgY6LhV4uviYJnX4bO79q0QCLcB\/s400\/Merge_sort_algorithm_diagram.png\" width=\"400\" \/\u003E\u003C\/a\u003E\u003C\/div\u003E\u003C\/div\u003E"},"link":[{"rel":"replies","type":"application/atom+xml","href":"https:\/\/geekfactorial.blogspot.com\/feeds\/4494505227464051338\/comments\/default","title":"Post Comments"},{"rel":"replies","type":"text/html","href":"https:\/\/geekfactorial.blogspot.com\/2016\/08\/merge-sort.html#comment-form","title":"0 Comments"},{"rel":"edit","type":"application/atom+xml","href":"https:\/\/www.blogger.com\/feeds\/4840603379647116080\/posts\/default\/4494505227464051338"},{"rel":"self","type":"application/atom+xml","href":"https:\/\/www.blogger.com\/feeds\/4840603379647116080\/posts\/default\/4494505227464051338"},{"rel":"alternate","type":"text/html","href":"https:\/\/geekfactorial.blogspot.com\/2016\/08\/merge-sort.html","title":"Merge Sort"}],"author":[{"name":{"$t":"Unknown"},"email":{"$t":"noreply@blogger.com"},"gd$image":{"rel":"http://schemas.google.com/g/2005#thumbnail","width":"16","height":"16","src":"https:\/\/img1.blogblog.com\/img\/b16-rounded.gif"}}],"media$thumbnail":{"xmlns$media":"http://search.yahoo.com/mrss/","url":"https:\/\/2.bp.blogspot.com\/-k3w6HykFvlo\/V6iwsQrya4I\/AAAAAAAAAeE\/jhm4v2Pd3esgY6LhV4uviYJnX4bO79q0QCLcB\/s72-c\/Merge_sort_algorithm_diagram.png","height":"72","width":"72"},"thr$total":{"$t":"0"}}]}});