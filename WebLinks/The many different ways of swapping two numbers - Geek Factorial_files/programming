// API callback
related_results_labels_thumbs({"version":"1.0","encoding":"UTF-8","feed":{"xmlns":"http://www.w3.org/2005/Atom","xmlns$openSearch":"http://a9.com/-/spec/opensearchrss/1.0/","xmlns$blogger":"http://schemas.google.com/blogger/2008","xmlns$georss":"http://www.georss.org/georss","xmlns$gd":"http://schemas.google.com/g/2005","xmlns$thr":"http://purl.org/syndication/thread/1.0","id":{"$t":"tag:blogger.com,1999:blog-4840603379647116080"},"updated":{"$t":"2019-06-10T14:01:16.582+05:30"},"category":[{"term":"programming"},{"term":"c"},{"term":"puzzles"},{"term":"algorithms"},{"term":"divide and conquer"},{"term":"bit manipulation"},{"term":"logical puzzles"},{"term":"brain teasers"},{"term":"lateral thinking"},{"term":"math and number puzzles"},{"term":"css"},{"term":"geek factorial"},{"term":"html"},{"term":"java"},{"term":"miscellaneous"},{"term":"web design"}],"title":{"type":"text","$t":"Geek Factorial"},"subtitle":{"type":"html","$t":"Programming problems • Geek life • Logical puzzles • \u0026amp; more"},"link":[{"rel":"http://schemas.google.com/g/2005#feed","type":"application/atom+xml","href":"https:\/\/geekfactorial.blogspot.com\/feeds\/posts\/default"},{"rel":"self","type":"application/atom+xml","href":"https:\/\/www.blogger.com\/feeds\/4840603379647116080\/posts\/default\/-\/programming?alt=json-in-script\u0026max-results=8"},{"rel":"alternate","type":"text/html","href":"https:\/\/geekfactorial.blogspot.com\/search\/label\/programming"},{"rel":"hub","href":"http://pubsubhubbub.appspot.com/"},{"rel":"next","type":"application/atom+xml","href":"https:\/\/www.blogger.com\/feeds\/4840603379647116080\/posts\/default\/-\/programming\/-\/programming?alt=json-in-script\u0026start-index=9\u0026max-results=8"}],"author":[{"name":{"$t":"Unknown"},"email":{"$t":"noreply@blogger.com"},"gd$image":{"rel":"http://schemas.google.com/g/2005#thumbnail","width":"16","height":"16","src":"https:\/\/img1.blogblog.com\/img\/b16-rounded.gif"}}],"generator":{"version":"7.00","uri":"http://www.blogger.com","$t":"Blogger"},"openSearch$totalResults":{"$t":"17"},"openSearch$startIndex":{"$t":"1"},"openSearch$itemsPerPage":{"$t":"8"},"entry":[{"id":{"$t":"tag:blogger.com,1999:blog-4840603379647116080.post-3379321338524923678"},"published":{"$t":"2016-08-19T22:12:00.000+05:30"},"updated":{"$t":"2016-08-19T22:22:32.642+05:30"},"category":[{"scheme":"http://www.blogger.com/atom/ns#","term":"bit manipulation"},{"scheme":"http://www.blogger.com/atom/ns#","term":"c"},{"scheme":"http://www.blogger.com/atom/ns#","term":"programming"}],"title":{"type":"text","$t":"Write a program to get the nth byte of an integer"},"content":{"type":"html","$t":"\u003Cdiv dir=\"ltr\" style=\"text-align: left;\" trbidi=\"on\"\u003E\u003Cb\u003EProblem statement:\u003C\/b\u003E Given an integer, write a program to extract the nth byte from it.\u003Cbr \/\u003E\u003Cbr \/\u003EExample: Let's take an integer in hexadecimal format, say 0x\u003Cb\u003E5510EF3A\u003C\/b\u003E (a 32-bit integer). It has four bytes, given in hexadecimal as:\u003Cbr \/\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Byte 0: 0x\u003Cb\u003E3A\u003C\/b\u003E\u003Cbr \/\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Byte 1: 0x\u003Cb\u003EEF\u003C\/b\u003E\u003Cbr \/\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Byte 2: 0x\u003Cb\u003E10\u003C\/b\u003E\u003Cbr \/\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Byte 3: 0x\u003Cb\u003E55\u003C\/b\u003E\u003Cbr \/\u003ESo, if we want to get byte #2, the result would be 0x\u003Cb\u003E10\u003C\/b\u003E.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cb\u003ESolution:\u003C\/b\u003E We can move the required byte to the rightmost position by right-shifting the number by (8 * required byte number). Now we only need the rightmost byte in our result (the last 8 bits), so we can mask it by doing bitwise AND with 0x000000FF, which is also written as just 0xFF, or 255 in decimal.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cpre class=\"brush:cpp; code\"\u003E#include \u0026lt;stdio.h\u0026gt;\u003Cbr \/\u003E\u003Cbr \/\u003Eint getByte(int num, unsigned byteno)\u003Cbr \/\u003E{\u003Cbr \/\u003E    return (num \u003E\u003E (byteno * 8)) \u0026 0xFF;    \/\/ Mask and return the required byte\u003Cbr \/\u003E}\u003Cbr \/\u003E\u003Cbr \/\u003Eint main()\u003Cbr \/\u003E{\u003Cbr \/\u003E    int num;\u003Cbr \/\u003E    unsigned byteno;\u003Cbr \/\u003E\u003Cbr \/\u003E    printf(\"\\nEnter a hex number: \");\u003Cbr \/\u003E    scanf(\"%x\", \u0026num);        \/\/ To take input number in hex, by using %x\u003Cbr \/\u003E    printf(\"\\nEnter byte no to get (0 - 3): \");\u003Cbr \/\u003E    scanf(\"%u\", \u0026byteno);     \/\/ To take byte no in unsigned decimal, by using %u\u003Cbr \/\u003E\u003Cbr \/\u003E    printf(\"\\nByte no %u in hex representation: %x\\n\", byteno, getByte(num, byteno));\u003Cbr \/\u003E\u003Cbr \/\u003E    return 0;\u003Cbr \/\u003E}\u003Cbr \/\u003E\u003C\/pre\u003E\u003C\/div\u003E"},"link":[{"rel":"replies","type":"application/atom+xml","href":"https:\/\/geekfactorial.blogspot.com\/feeds\/3379321338524923678\/comments\/default","title":"Post Comments"},{"rel":"replies","type":"text/html","href":"https:\/\/geekfactorial.blogspot.com\/2016\/08\/write-a-program-to-get-the-nth-byte-of-an-integer.html#comment-form","title":"0 Comments"},{"rel":"edit","type":"application/atom+xml","href":"https:\/\/www.blogger.com\/feeds\/4840603379647116080\/posts\/default\/3379321338524923678"},{"rel":"self","type":"application/atom+xml","href":"https:\/\/www.blogger.com\/feeds\/4840603379647116080\/posts\/default\/3379321338524923678"},{"rel":"alternate","type":"text/html","href":"https:\/\/geekfactorial.blogspot.com\/2016\/08\/write-a-program-to-get-the-nth-byte-of-an-integer.html","title":"Write a program to get the nth byte of an integer"}],"author":[{"name":{"$t":"Unknown"},"email":{"$t":"noreply@blogger.com"},"gd$image":{"rel":"http://schemas.google.com/g/2005#thumbnail","width":"16","height":"16","src":"https:\/\/img1.blogblog.com\/img\/b16-rounded.gif"}}],"thr$total":{"$t":"0"}},{"id":{"$t":"tag:blogger.com,1999:blog-4840603379647116080.post-8864731630347790989"},"published":{"$t":"2016-08-19T20:05:00.000+05:30"},"updated":{"$t":"2016-08-19T20:27:03.022+05:30"},"category":[{"scheme":"http://www.blogger.com/atom/ns#","term":"bit manipulation"},{"scheme":"http://www.blogger.com/atom/ns#","term":"c"},{"scheme":"http://www.blogger.com/atom/ns#","term":"programming"}],"title":{"type":"text","$t":"Check if two integers are equal without using any comparison operators"},"content":{"type":"html","$t":"\u003Cdiv dir=\"ltr\" style=\"text-align: left;\" trbidi=\"on\"\u003E\u003Cb\u003EProblem statement:\u003C\/b\u003E Given two integers, you need to check if they are equal or not, without using any comparison operators.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cb\u003ESolution:\u003C\/b\u003E An optimized solution can be given using bitwise XOR operator. The bitwise XOR of two numbers is 0 only if each corresponding bit in the two numbers is same, i.e. the numbers are equal.\u003Cbr \/\u003E\u003Cpre class=\"brush:cpp; code\"\u003Eint isUnequal(int a, int b)\u003Cbr \/\u003E{\u003Cbr \/\u003E    return a ^ b;    \/\/ Returns zero if the numbers are equal, else a non-zero value\u003Cbr \/\u003E}\u003Cbr \/\u003E\u003C\/pre\u003E\u003Cbr \/\u003ESince (a ^ b) might be any integer value, we can strictly restrict the return value to either 0 or 1 like this:\u003Cbr \/\u003E\u003Cpre class=\"brush:cpp; code\"\u003Eint isUnequal(int a, int b)\u003Cbr \/\u003E{\u003Cbr \/\u003E    return !!(a ^ b);    \/\/ Returns zero if the numbers are equal, else returns one\u003Cbr \/\u003E}\u003Cbr \/\u003E\u003C\/pre\u003E\u003Cbr \/\u003EAnother simple solution could be using the minus operator:\u003Cbr \/\u003E\u003Cpre class=\"brush:cpp; code\"\u003Eint isUnequal(int a, int b)\u003Cbr \/\u003E{\u003Cbr \/\u003E    return !!(a - b);    \/\/ Returns zero if the numbers are equal, else returns one\u003Cbr \/\u003E}\u003Cbr \/\u003E\u003C\/pre\u003E\u003C\/div\u003E"},"link":[{"rel":"replies","type":"application/atom+xml","href":"https:\/\/geekfactorial.blogspot.com\/feeds\/8864731630347790989\/comments\/default","title":"Post Comments"},{"rel":"replies","type":"text/html","href":"https:\/\/geekfactorial.blogspot.com\/2016\/08\/check-if-two-integers-are-equal-without-using-any-comparison-operators.html#comment-form","title":"0 Comments"},{"rel":"edit","type":"application/atom+xml","href":"https:\/\/www.blogger.com\/feeds\/4840603379647116080\/posts\/default\/8864731630347790989"},{"rel":"self","type":"application/atom+xml","href":"https:\/\/www.blogger.com\/feeds\/4840603379647116080\/posts\/default\/8864731630347790989"},{"rel":"alternate","type":"text/html","href":"https:\/\/geekfactorial.blogspot.com\/2016\/08\/check-if-two-integers-are-equal-without-using-any-comparison-operators.html","title":"Check if two integers are equal without using any comparison operators"}],"author":[{"name":{"$t":"Unknown"},"email":{"$t":"noreply@blogger.com"},"gd$image":{"rel":"http://schemas.google.com/g/2005#thumbnail","width":"16","height":"16","src":"https:\/\/img1.blogblog.com\/img\/b16-rounded.gif"}}],"thr$total":{"$t":"0"}},{"id":{"$t":"tag:blogger.com,1999:blog-4840603379647116080.post-5584655745460470505"},"published":{"$t":"2016-08-19T00:12:00.001+05:30"},"updated":{"$t":"2016-08-19T00:27:42.079+05:30"},"category":[{"scheme":"http://www.blogger.com/atom/ns#","term":"bit manipulation"},{"scheme":"http://www.blogger.com/atom/ns#","term":"c"},{"scheme":"http://www.blogger.com/atom/ns#","term":"programming"}],"title":{"type":"text","$t":"Find the number of bits to be flipped to convert number A to number B"},"content":{"type":"html","$t":"\u003Cdiv dir=\"ltr\" style=\"text-align: left;\" trbidi=\"on\"\u003E\u003Cb\u003EProblem statement:\u003C\/b\u003E You are given two numbers A and B. Write a program to count the number of bits needed to be flipped to convert A to B.\u003Cbr \/\u003E\u003Cbr \/\u003EExample: Let A = 5 and B = 3, then they can be represented in binary as:\u003Cbr \/\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; A = 1 0 1\u003Cbr \/\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; B = 0 1 1\u003Cbr \/\u003EAs can be seen, total 2 bits are needed to be flipped to convert A to B in this case.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cb\u003ESolution:\u003C\/b\u003E This problem can be restated as to find the number of dissimilar corresponding bits in A and B. And the bitwise XOR operator (\u003Ci\u003E^\u003C\/i\u003E) can help us in finding that. The XOR of two bits is 1 only when the bits are not same. So, our solution involves two simple steps:\u003Cbr \/\u003E\u003Cbr \/\u003E1. Find the bitwise XOR of A and B.\u003Cbr \/\u003E2. Count the number of set bits in the result.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cpre class=\"brush:cpp; code\"\u003Eint countFlippedBits(int a, int b)\u003Cbr \/\u003E{\u003Cbr \/\u003E    unsigned int count = 0;\u003Cbr \/\u003E\u003Cbr \/\u003E    \/* Bitwise XOR of a and b *\/\u003Cbr \/\u003E    unsigned int x = a ^ b;\u003Cbr \/\u003E\u003Cbr \/\u003E    \/* Finding the no. of set bits in the XOR result *\/\u003Cbr \/\u003E    while (x)\u003Cbr \/\u003E    {\u003Cbr \/\u003E        count += (x \u0026 1);\u003Cbr \/\u003E        x \u003E\u003E= 1;\u003Cbr \/\u003E    }\u003Cbr \/\u003E\u003Cbr \/\u003E    return count;\u003Cbr \/\u003E}\u003Cbr \/\u003E\u003C\/pre\u003E\u003C\/div\u003E"},"link":[{"rel":"replies","type":"application/atom+xml","href":"https:\/\/geekfactorial.blogspot.com\/feeds\/5584655745460470505\/comments\/default","title":"Post Comments"},{"rel":"replies","type":"text/html","href":"https:\/\/geekfactorial.blogspot.com\/2016\/08\/find-the-number-of-bits-to-be-flipped-to-convert-number-a-to-number-b.html#comment-form","title":"0 Comments"},{"rel":"edit","type":"application/atom+xml","href":"https:\/\/www.blogger.com\/feeds\/4840603379647116080\/posts\/default\/5584655745460470505"},{"rel":"self","type":"application/atom+xml","href":"https:\/\/www.blogger.com\/feeds\/4840603379647116080\/posts\/default\/5584655745460470505"},{"rel":"alternate","type":"text/html","href":"https:\/\/geekfactorial.blogspot.com\/2016\/08\/find-the-number-of-bits-to-be-flipped-to-convert-number-a-to-number-b.html","title":"Find the number of bits to be flipped to convert number A to number B"}],"author":[{"name":{"$t":"Unknown"},"email":{"$t":"noreply@blogger.com"},"gd$image":{"rel":"http://schemas.google.com/g/2005#thumbnail","width":"16","height":"16","src":"https:\/\/img1.blogblog.com\/img\/b16-rounded.gif"}}],"thr$total":{"$t":"0"}},{"id":{"$t":"tag:blogger.com,1999:blog-4840603379647116080.post-45975322573881323"},"published":{"$t":"2016-08-16T20:09:00.003+05:30"},"updated":{"$t":"2016-08-16T20:09:50.869+05:30"},"category":[{"scheme":"http://www.blogger.com/atom/ns#","term":"c"},{"scheme":"http://www.blogger.com/atom/ns#","term":"programming"}],"title":{"type":"text","$t":"Passing NULL to printf() in C"},"content":{"type":"html","$t":"\u003Cdiv dir=\"ltr\" style=\"text-align: left;\" trbidi=\"on\"\u003EConsider the following code snippet:\u003Cbr \/\u003E\u003Cpre class=\"brush:cpp; code\"\u003Echar *p = NULL;\u003Cbr \/\u003Eprintf (\"%s\", p);\u003Cbr \/\u003E\u003C\/pre\u003EWhat should be the output of the above code?\u003Cbr \/\u003E\u003Cbr \/\u003EThe printf() function with \"%s\" format specifier expects a '\\0'-terminated array of characters (or string literal) whereas it receives a null pointer. Passing NULL to printf() is undefined behavior in C.\u003Cbr \/\u003E\u003Cbr \/\u003EAccording to Section 7.1.4 (of C99 or C11): Use of library functions,\u003Cbr \/\u003E\u003Cb\u003E\"If an argument to a function has an invalid value (such as a value outside the domain of the function, or a pointer outside the address space of the program, or a null pointer, or a pointer to non-modifiable storage when the corresponding parameter is not const-qualified) or a type (after promotion) not expected by a function with variable number of arguments, the behavior is undefined.\"\u003C\/b\u003E\u003Cbr \/\u003E\u003Cbr \/\u003ESome compilers may produce \"(null)\" written on the screen while others may give segmentation fault. GCC prints (null).\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cb\u003EWhat is NULL?\u003C\/b\u003E\u003Cbr \/\u003ENULL is a macro defined by several headers (including stdio.h, stddef.h, stdlib.h, string.h, time.h etc.) as a null pointer constant, typically \u003Cb\u003E0\u003C\/b\u003E or \u003Cb\u003E((void *)0)\u003C\/b\u003E. It is a value which is \"guaranteed to compare unequal to a pointer to any object or function\", as per C standard. That is, a null pointer points definitively nowhere - it is never the address of any object or function. The address-of operator '\u0026' will never yield a null pointer, nor will a successful call to malloc() (malloc does return a null pointer when it fails).\u003Cbr \/\u003E\u003Cbr \/\u003EHere is a program to demonstrate the effect of passing null pointer to printf() with different format specifiers.\u003Cbr \/\u003E\u003Cpre class=\"brush:cpp; code\"\u003E\/* Effects of passing null pointer to printf() *\/\u003Cbr \/\u003E\u003Cbr \/\u003E#include \u0026lt;stdio.h\u0026gt;\u003Cbr \/\u003Eint main()\u003Cbr \/\u003E{\u003Cbr \/\u003E    printf (\"%s \\n\", NULL);  \/\/ Undefined behavior, prints (null) in GCC\u003Cbr \/\u003E    printf (\"%d \\n\", NULL);  \/\/ The value of NULL macro (typically 0)\u003Cbr \/\u003E    printf (\"%c \\n\", NULL);  \/\/ The ASCII character corresponding to the value of NULL macro\u003Cbr \/\u003E                             \/\/ (generally value is 0, so null character '\\0', i.e. blank result).\u003Cbr \/\u003E    return 0;\u003Cbr \/\u003E}\u003Cbr \/\u003E\u003C\/pre\u003E\u003Cbr \/\u003EOutput in GCC:\u003Cbr \/\u003E\u003Cdiv class=\"output\"\u003E(null)\u003Cbr \/\u003E0\u003Cbr \/\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003C\/div\u003E"},"link":[{"rel":"replies","type":"application/atom+xml","href":"https:\/\/geekfactorial.blogspot.com\/feeds\/45975322573881323\/comments\/default","title":"Post Comments"},{"rel":"replies","type":"text/html","href":"https:\/\/geekfactorial.blogspot.com\/2016\/08\/passing-null-to-printf-in-c.html#comment-form","title":"0 Comments"},{"rel":"edit","type":"application/atom+xml","href":"https:\/\/www.blogger.com\/feeds\/4840603379647116080\/posts\/default\/45975322573881323"},{"rel":"self","type":"application/atom+xml","href":"https:\/\/www.blogger.com\/feeds\/4840603379647116080\/posts\/default\/45975322573881323"},{"rel":"alternate","type":"text/html","href":"https:\/\/geekfactorial.blogspot.com\/2016\/08\/passing-null-to-printf-in-c.html","title":"Passing NULL to printf() in C"}],"author":[{"name":{"$t":"Unknown"},"email":{"$t":"noreply@blogger.com"},"gd$image":{"rel":"http://schemas.google.com/g/2005#thumbnail","width":"16","height":"16","src":"https:\/\/img1.blogblog.com\/img\/b16-rounded.gif"}}],"thr$total":{"$t":"0"}},{"id":{"$t":"tag:blogger.com,1999:blog-4840603379647116080.post-8580898793592244625"},"published":{"$t":"2016-08-15T14:00:00.000+05:30"},"updated":{"$t":"2016-08-16T15:21:34.102+05:30"},"category":[{"scheme":"http://www.blogger.com/atom/ns#","term":"algorithms"},{"scheme":"http://www.blogger.com/atom/ns#","term":"programming"}],"title":{"type":"text","$t":"The many different ways of swapping two numbers"},"content":{"type":"html","$t":"\u003Cdiv dir=\"ltr\" style=\"text-align: left;\" trbidi=\"on\"\u003EOne of the most seen snippets of code is the one that swaps the values of two variables. This little job is crucial to many algorithms, and there are multiple ways of doing it. Generally, for swapping two variables we use a temporary third variable, but various other ways do not even require the help of any third variable.\u003Cbr \/\u003E\u003Cdiv class=\"separator\" style=\"clear: both; text-align: center;\"\u003E\u003Ca href=\"https:\/\/1.bp.blogspot.com\/-S4rCg9H-chM\/V7Fy-fLLLjI\/AAAAAAAAAfs\/ehW6g-nFEwIqZ9ng0vcBy2djhTTZDH8fACLcB\/s1600\/lets-swap-it.jpg\" imageanchor=\"1\" style=\"margin-left: 1em; margin-right: 1em;\"\u003E\u003Cimg border=\"0\" height=\"281\" src=\"https:\/\/1.bp.blogspot.com\/-S4rCg9H-chM\/V7Fy-fLLLjI\/AAAAAAAAAfs\/ehW6g-nFEwIqZ9ng0vcBy2djhTTZDH8fACLcB\/s640\/lets-swap-it.jpg\" width=\"640\" \/\u003E\u003C\/a\u003E\u003C\/div\u003EI find it very interesting that there are so many ways of doing this seemingly simple job and so, I thought to share all the ways I know of swapping two numbers...\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cb\u003E1. The simple method using a third variable\u003C\/b\u003E\u003Cbr \/\u003E\u003Cpre class=\"brush:cpp; highlight:[7, 8, 9]; code\"\u003E#include \u0026lt;stdio.h\u0026gt;\u003Cbr \/\u003Eint main()\u003Cbr \/\u003E{\u003Cbr \/\u003E    int a = 10, b = 5, temp;\u003Cbr \/\u003E\u003Cbr \/\u003E    \/\/ Code to swap a and b:\u003Cbr \/\u003E    temp = a;\u003Cbr \/\u003E    a = b;\u003Cbr \/\u003E    b = temp;\u003Cbr \/\u003E\u003Cbr \/\u003E    printf(\"After swapping: a = %d, b = %d\", a, b);\u003Cbr \/\u003E    return 0;\u003Cbr \/\u003E}\u003Cbr \/\u003E\u003C\/pre\u003E\u003Cbr \/\u003ENow let's look at some methods which do not require any additional variables.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cb\u003E2. Using arithmetic operators + and -\u003C\/b\u003E\u003Cbr \/\u003E\u003Cpre class=\"brush:cpp; code\"\u003Ea = a + b;\u003Cbr \/\u003Eb = a - b;\u003Cbr \/\u003Ea = a - b;\u003Cbr \/\u003E\u003C\/pre\u003EThe above way works well, but it may cause arithmetic overflow when adding large numbers.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cb\u003E3. Using arithmetic operators * and \/\u003C\/b\u003E\u003Cbr \/\u003E\u003Cpre class=\"brush:cpp; code\"\u003Ea = a * b;\u003Cbr \/\u003Eb = a \/ b;\u003Cbr \/\u003Ea = a \/ b;\u003Cbr \/\u003E\u003C\/pre\u003EThis way will not work if one of the numbers is zero, as the product becomes zero. It may also cause arithmetic overflow when multiplying large numbers.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cb\u003E4. Using bitwise XOR operator ^\u003C\/b\u003E\u003Cbr \/\u003E\u003Cpre class=\"brush:cpp; code\"\u003Ea = a ^ b;\u003Cbr \/\u003Eb = a ^ b;\u003Cbr \/\u003Ea = a ^ b;\u003Cbr \/\u003E\u003C\/pre\u003EThis method is perhaps a bit more efficient, because it uses bitwise operator only. It can also be written in a more compact manner like this:\u003Cbr \/\u003E\u003Cpre class=\"brush:cpp; code\"\u003Ea ^= b;\u003Cbr \/\u003Eb ^= a;\u003Cbr \/\u003Ea ^= b;\u003Cbr \/\u003E\u003C\/pre\u003E\u003Cbr \/\u003E\u003Cb\u003ENote:\u003C\/b\u003E When using pointers to the variables, \u003Ci\u003Ethe above methods 2, 3 and 4 will fail if both the pointers point to the same variable\u003C\/i\u003E. Example: If a function to swap two variables is accepting the addresses of the two variables, then a call like \u003Ci\u003Eswap(\u0026a, \u0026a);\u003C\/i\u003E should make no effect on the value of variable a, but in the above methods (except method 1) the variable will store incorrect value. So, we need to firstly check if both the pointers are exactly the same. A good example of using the above swap methods with pointers can be like:\u003Cbr \/\u003E\u003Cpre class=\"brush:cpp; code\"\u003Evoid swap(int *x, int *y)\u003Cbr \/\u003E{\u003Cbr \/\u003E    if(x != y)    \/\/ Checking that x and y are not pointing to the same location\u003Cbr \/\u003E    {\u003Cbr \/\u003E        *x ^= *y;\u003Cbr \/\u003E        *y ^= *x;\u003Cbr \/\u003E        *x ^= *y;\u003Cbr \/\u003E    }\u003Cbr \/\u003E}\u003Cbr \/\u003E\u003C\/pre\u003E\u003Cbr \/\u003E\u003Cb\u003E5. Using bitwise XOR operator ^ in one line\u003C\/b\u003E\u003Cbr \/\u003E\u003Cpre class=\"brush:cpp; code\"\u003Ea ^= b ^= a ^= b;\u003Cbr \/\u003E\u003C\/pre\u003EThis is similar to method 4 but three statements have been compounded into one. Order of evaluation is from right to left.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cb\u003E6. Using arithmetic operators + and - in one line\u003C\/b\u003E\u003Cbr \/\u003E\u003Cpre class=\"brush:cpp; code\"\u003Ea = (a + b) - (b = a);\u003Cbr \/\u003E\u003C\/pre\u003EThe problem of arithmetic overflow can occur in this method.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cb\u003E7. Using arithmetic operators * and \/ in one line\u003C\/b\u003E\u003Cbr \/\u003E\u003Cpre class=\"brush:cpp; code\"\u003Ea = (a * b) \/ (b = a);\u003Cbr \/\u003E\u003C\/pre\u003EThe problem of arithmetic overflow can occur in this method. Also, it will show undefined behavior if the first number a = 0 (because that will lead to division by zero).\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cb\u003E8. Using arithmetic operators + and - in a slightly different way\u003C\/b\u003E\u003Cbr \/\u003E\u003Cpre class=\"brush:cpp; code\"\u003Ea = b - a;\u003Cbr \/\u003Eb = b - a;\u003Cbr \/\u003Ea = b + a;\u003Cbr \/\u003E\u003C\/pre\u003ENote that the corresponding method with * and \/ operators does not work.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cb\u003ENote:\u003C\/b\u003E The methods 5, 6, 7 and 8 also work well when using pointers to the variables. But \u003Ci\u003Emethods 5 and 8 will give wrong result if the pointers point to the same location\u003C\/i\u003E.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cb\u003E9. Using a file as buffer\u003C\/b\u003E\u003Cbr \/\u003E\u003Cpre class=\"brush:cpp; code\"\u003EFILE *fp;\u003Cbr \/\u003E\u003Cbr \/\u003Efprintf(fp = fopen(\"temp.txt\", \"w\"), \"%d\", a);\u003Cbr \/\u003Efclose(fp);\u003Cbr \/\u003Ea = b;\u003Cbr \/\u003Efscanf(fp = fopen(\"temp.txt\", \"r\"), \"%d\", \u0026b);\u003Cbr \/\u003Efclose(fp);\u003Cbr \/\u003E\u003C\/pre\u003EOf course, using such a method incurs a lot more overhead than the usual methods. Just included for theoretical purposes.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cb\u003E10. Using a \u003Ca href=\"https:\/\/geekfactorial.blogspot.com\/2016\/08\/command-line-arguments-and-their-implementation-in-c.html\"\u003Ecommand-line-related variable\u003C\/a\u003E as buffer\u003C\/b\u003E\u003Cbr \/\u003E\u003Cpre class=\"brush:cpp; code\"\u003Eint main(int argc, char **argv)\u003Cbr \/\u003E{\u003Cbr \/\u003E    int a = 10, b = 5;\u003Cbr \/\u003E\u003Cbr \/\u003E    argc = a;\u003Cbr \/\u003E    a = b;\u003Cbr \/\u003E    b = argc;\u003Cbr \/\u003E\u003Cbr \/\u003E    printf(\"After swapping: a = %d, b = %d\", a, b);\u003Cbr \/\u003E    return 0;\u003Cbr \/\u003E}\u003Cbr \/\u003E\u003C\/pre\u003E\u003Cbr \/\u003E\u003Cb\u003E11. Using a macro\u003C\/b\u003E\u003Cbr \/\u003E\u003Cpre class=\"brush:cpp; code\"\u003E#define SWAP(x, y, Type) Type temp = x; x = y; y = temp;\u003Cbr \/\u003E\u003Cbr \/\u003Eint main()\u003Cbr \/\u003E{\u003Cbr \/\u003E    int a = 10, b = 5;\u003Cbr \/\u003E\u003Cbr \/\u003E    SWAP(a, b, int);\u003Cbr \/\u003E\u003Cbr \/\u003E    printf(\"After swapping: a = %d, b = %d\", a, b);\u003Cbr \/\u003E    return 0;\u003Cbr \/\u003E}\u003Cbr \/\u003E\u003C\/pre\u003EIts advantage is that it is generic up to some extent. The same SWAP macro will work for types like int, float and char. By using this GCC-specific extension, we can improve it further like:\u003Cbr \/\u003E\u003Cpre class=\"brush:cpp; code\"\u003E#define SWAP(x, y) typeof(x) temp = x; x = y; y = temp;\u003Cbr \/\u003E\u003C\/pre\u003EThe problem with method 11 will arise when there is already a variable named temp in the program!\u003Cbr \/\u003E\u003C\/div\u003E"},"link":[{"rel":"replies","type":"application/atom+xml","href":"https:\/\/geekfactorial.blogspot.com\/feeds\/8580898793592244625\/comments\/default","title":"Post Comments"},{"rel":"replies","type":"text/html","href":"https:\/\/geekfactorial.blogspot.com\/2016\/08\/the-many-different-ways-of-swapping-two-numbers.html#comment-form","title":"0 Comments"},{"rel":"edit","type":"application/atom+xml","href":"https:\/\/www.blogger.com\/feeds\/4840603379647116080\/posts\/default\/8580898793592244625"},{"rel":"self","type":"application/atom+xml","href":"https:\/\/www.blogger.com\/feeds\/4840603379647116080\/posts\/default\/8580898793592244625"},{"rel":"alternate","type":"text/html","href":"https:\/\/geekfactorial.blogspot.com\/2016\/08\/the-many-different-ways-of-swapping-two-numbers.html","title":"The many different ways of swapping two numbers"}],"author":[{"name":{"$t":"Unknown"},"email":{"$t":"noreply@blogger.com"},"gd$image":{"rel":"http://schemas.google.com/g/2005#thumbnail","width":"16","height":"16","src":"https:\/\/img1.blogblog.com\/img\/b16-rounded.gif"}}],"media$thumbnail":{"xmlns$media":"http://search.yahoo.com/mrss/","url":"https:\/\/1.bp.blogspot.com\/-S4rCg9H-chM\/V7Fy-fLLLjI\/AAAAAAAAAfs\/ehW6g-nFEwIqZ9ng0vcBy2djhTTZDH8fACLcB\/s72-c\/lets-swap-it.jpg","height":"72","width":"72"},"thr$total":{"$t":"0"}},{"id":{"$t":"tag:blogger.com,1999:blog-4840603379647116080.post-6020248845689795675"},"published":{"$t":"2016-08-14T18:05:00.001+05:30"},"updated":{"$t":"2016-08-14T23:00:28.044+05:30"},"category":[{"scheme":"http://www.blogger.com/atom/ns#","term":"c"},{"scheme":"http://www.blogger.com/atom/ns#","term":"programming"}],"title":{"type":"text","$t":"Implement a program that sorts given data according to the switch provided by the user"},"content":{"type":"html","$t":"\u003Cdiv dir=\"ltr\" style=\"text-align: left;\" trbidi=\"on\"\u003ECommand line arguments, as discussed \u003Ca href=\"https:\/\/geekfactorial.blogspot.com\/2016\/08\/command-line-arguments-and-their-implementation-in-c.html\"\u003Ehere\u003C\/a\u003E, can be used to make a program run differently on different executions. The user is able to pass additional parameters while running a program, so that it can behave in different ways based on the user's request. We are going to implement one such program here.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cbig\u003E\u003Cb\u003EProblem statement:\u003C\/b\u003E\u003C\/big\u003E Implement a program which sorts the data given in command line arguments according to the switch provided by the user, as explained below:\u003Cbr \/\u003E\u003Cb\u003ENo switch\u003C\/b\u003E : Sort lexicographically\u003Cbr \/\u003E\u003Cb\u003E\u003Ci\u003E-i\u003C\/i\u003E\u003C\/b\u003E : Sort lexicographically ignoring the case\u003Cbr \/\u003E\u003Cb\u003E\u003Ci\u003E-n\u003C\/i\u003E\u003C\/b\u003E : Sort numerically\u003Cbr \/\u003E\u003Cb\u003E\u003Ci\u003E-r\u003C\/i\u003E\u003C\/b\u003E : Sort numerically in reverse\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cb\u003ESample execution 1:\u003C\/b\u003E\u003Cbr \/\u003E.\/a.out geek factorial aaa BCD 202 21\u003Cbr \/\u003E\u003Cb\u003ESample output 1:\u003C\/b\u003E\u003Cbr \/\u003ENo switch detected. Sorting lexicographically:\u003Cbr \/\u003E202\u003Cbr \/\u003E21\u003Cbr \/\u003EBCD\u003Cbr \/\u003Eaaa\u003Cbr \/\u003Efactorial\u003Cbr \/\u003Egeek\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cb\u003ESample execution 2:\u003C\/b\u003E\u003Cbr \/\u003E.\/a.out -i BCD aaa\u003Cbr \/\u003E\u003Cb\u003ESample output 2:\u003C\/b\u003E\u003Cbr \/\u003ESwitch -i detected. Sorting lexicographically ignoring the case:\u003Cbr \/\u003Eaaa\u003Cbr \/\u003EBCD\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cb\u003ESample execution 3:\u003C\/b\u003E\u003Cbr \/\u003E.\/a.out -n 101 30 60\u003Cbr \/\u003E\u003Cb\u003ESample output 3:\u003C\/b\u003E\u003Cbr \/\u003ESwitch -n detected. Sorting numerically:\u003Cbr \/\u003E30\u003Cbr \/\u003E60\u003Cbr \/\u003E101\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cb\u003ESample execution 4:\u003C\/b\u003E\u003Cbr \/\u003E.\/a.out -r 101 30 60\u003Cbr \/\u003E\u003Cb\u003ESample output 4:\u003C\/b\u003E\u003Cbr \/\u003ESwitch -r detected. Sorting numerically in reverse:\u003Cbr \/\u003E101\u003Cbr \/\u003E60\u003Cbr \/\u003E30\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cbig\u003E\u003Cb\u003ESolution (using command line arguments as switches and a single sort function):\u003C\/b\u003E\u003C\/big\u003E We can test if the first argument provided is recognized as a switch, and then we can do the operations accordingly. The following C program works on this concept. It uses one sort function to sort data in any manner based on different comparison functions (the appropriate comparison function is passed to it via function pointer, after recognizing the switch).\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cpre class=\"brush:cpp; code\"\u003E#include \u0026lt;stdio.h\u0026gt;\u003Cbr \/\u003E#include \u0026lt;string.h\u0026gt;\u003Cbr \/\u003E#include \u0026lt;ctype.h\u0026gt;\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cbr \/\u003E\/* The central sorting function which can take different comparison functions as argument via function pointer *\/\u003Cbr \/\u003Evoid sort(int argc, char *argv[], int (*compare)(char*, char*))\u003Cbr \/\u003E{\u003Cbr \/\u003E    int i, j;\u003Cbr \/\u003E    char *temp;\u003Cbr \/\u003E\u003Cbr \/\u003E    for(i = 1; i \u0026lt; argc - 1; i++)\u003Cbr \/\u003E        for(j = 1; j \u0026lt; argc - 1; j++)\u003Cbr \/\u003E            if((*compare)(argv[j], argv[j+1]) \u0026gt; 0)  \/\/ Make comparison according to the passed comparison function\u003Cbr \/\u003E            {\u003Cbr \/\u003E                temp = argv[j];        \/\/ Swapping of pointers to strings, argv[j] and argv[j+1]\u003Cbr \/\u003E                argv[j] = argv[j+1];\u003Cbr \/\u003E                argv[j+1] = temp;\u003Cbr \/\u003E            }\u003Cbr \/\u003E}\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cbr \/\u003E\/* Function to compare 2 strings (having numbers) numerically *\/\u003Cbr \/\u003Eint compNum(char *s1, char *s2)\u003Cbr \/\u003E{\u003Cbr \/\u003E    int n1, n2;\u003Cbr \/\u003E    sscanf(s1, \"%d\", \u0026n1);\u003Cbr \/\u003E    sscanf(s2, \"%d\", \u0026n2);\u003Cbr \/\u003E\u003Cbr \/\u003E    if(n1 \u0026gt; n2)\u003Cbr \/\u003E        return 1;\u003Cbr \/\u003E    else\u003Cbr \/\u003E        return 0;\u003Cbr \/\u003E}\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cbr \/\u003E\/* Function to compare 2 strings (having numbers) numerically (according to reverse\/descending order) *\/\u003Cbr \/\u003Eint compNumReverse(char *s1, char *s2)\u003Cbr \/\u003E{\u003Cbr \/\u003E    int n1, n2;\u003Cbr \/\u003E    sscanf(s1, \"%d\", \u0026n1);\u003Cbr \/\u003E    sscanf(s2, \"%d\", \u0026n2);\u003Cbr \/\u003E\u003Cbr \/\u003E    if(n1 \u0026lt; n2)\u003Cbr \/\u003E        return 1;\u003Cbr \/\u003E    else\u003Cbr \/\u003E        return 0;\u003Cbr \/\u003E}\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cbr \/\u003E\/* Function to compare 2 strings lexicographically *\/\u003Cbr \/\u003Eint compStr(char *s1, char *s2)\u003Cbr \/\u003E{\u003Cbr \/\u003E    if(strcmp(s1, s2) \u0026gt; 0)\u003Cbr \/\u003E        return 1;\u003Cbr \/\u003E    else\u003Cbr \/\u003E        return 0;\u003Cbr \/\u003E}\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cbr \/\u003E\/* Function to compare 2 strings lexicographically (ignoring the case) *\/\u003Cbr \/\u003Eint compStrIgnoreCase(char *s1, char *s2)\u003Cbr \/\u003E{\u003Cbr \/\u003E\u003Cbr \/\u003E    \/*\u003Cbr \/\u003E       We can use strcmpi(s1, s2) function to compare 2 strings ignoring their case. But strcmpi() is not a standard C function and may not work on every platform.\u003Cbr \/\u003E       Similarly, strlwr() and strupr() functions that can convert a passed string to lower and upper case respectively can be used here, but they are also non-standard.\u003Cbr \/\u003E       So, we should prefer using tolower() (or toupper()) functions which are standard functions defined in the header file \"ctype.h\" to convert a passed character variable to lowercase (or uppercase).\u003Cbr \/\u003E       We can convert strings to lowercase (or uppercase) character-by-character, as done below, and then compare them using strcmp(s1, s2) function.\u003Cbr \/\u003E    *\/\u003Cbr \/\u003E\u003Cbr \/\u003E    int i;\u003Cbr \/\u003E    char s11[strlen(s1)+1], s22[strlen(s2)+1];  \/\/ Make copy of strings and convert them to lowercase\u003Cbr \/\u003E    for(i = 0; s1[i]; i++)\u003Cbr \/\u003E        s11[i] = tolower(s1[i]);\u003Cbr \/\u003E    for(i = 0; s2[i]; i++)\u003Cbr \/\u003E        s22[i] = tolower(s2[i]);\u003Cbr \/\u003E\u003Cbr \/\u003E    if(strcmp(s11, s22) \u0026gt; 0)  \/\/ Compare the duplicated and lowercased strings\u003Cbr \/\u003E        return 1;\u003Cbr \/\u003E    else\u003Cbr \/\u003E        return 0;\u003Cbr \/\u003E}\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cbr \/\u003E\/* Function for left shifting the array of strings by one, to remove the first string having the switch, and reduce argc by 1 *\/\u003Cbr \/\u003Evoid leftShift(int *argcPtr, char *argv[])\u003Cbr \/\u003E{\u003Cbr \/\u003E    int i;\u003Cbr \/\u003E    for(i = 1; i \u0026lt; (*argcPtr) - 1; i++)\u003Cbr \/\u003E        argv[i] = argv[i+1];  \/\/ Just make each argv[i] poiner point to the next string\u003Cbr \/\u003E\u003Cbr \/\u003E    (*argcPtr)--;  \/\/ Reduce (*argcPtr) by one\u003Cbr \/\u003E}\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cbr \/\u003E\/* Main function *\/\u003Cbr \/\u003Eint main(int argc, char *argv[])\u003Cbr \/\u003E{\u003Cbr \/\u003E    int i;\u003Cbr \/\u003E\u003Cbr \/\u003E    \/* Check if no arguments are provided, then return *\/\u003Cbr \/\u003E    if(argc == 1)\u003Cbr \/\u003E    {\u003Cbr \/\u003E        printf(\"\\nNo input command line arguments provided.\\n\");\u003Cbr \/\u003E        return 0;\u003Cbr \/\u003E    }\u003Cbr \/\u003E\u003Cbr \/\u003E    if(strcmp(argv[1], \"-n\") == 0)         \/\/ Switch \"-n\" was given\u003Cbr \/\u003E    {\u003Cbr \/\u003E        \/* Left shift the array of strings by one to remove the string having the switch, and reduce argc by 1 *\/\u003Cbr \/\u003E        leftShift(\u0026argc, argv);\u003Cbr \/\u003E\u003Cbr \/\u003E        printf(\"\\nSwitch -n detected. Sorting numerically:\\n\");\u003Cbr \/\u003E        \/* Call sort() function with appropriate comparison function passed as argument *\/\u003Cbr \/\u003E        sort(argc, argv, compNum);\u003Cbr \/\u003E    }\u003Cbr \/\u003E    else if(strcmp(argv[1], \"-r\") == 0)    \/\/ Switch \"-r\" was given\u003Cbr \/\u003E    {\u003Cbr \/\u003E        leftShift(\u0026argc, argv);\u003Cbr \/\u003E\u003Cbr \/\u003E        printf(\"\\nSwitch -r detected. Sorting numerically in reverse:\\n\");\u003Cbr \/\u003E        sort(argc, argv, compNumReverse);\u003Cbr \/\u003E    }\u003Cbr \/\u003E    else if(strcmp(argv[1], \"-i\") == 0)    \/\/ Switch \"-i\" was given\u003Cbr \/\u003E    {\u003Cbr \/\u003E        leftShift(\u0026argc, argv);\u003Cbr \/\u003E\u003Cbr \/\u003E        printf(\"\\nSwitch -i detected. Sorting lexicographically ignoring the case:\\n\");\u003Cbr \/\u003E        sort(argc, argv, compStrIgnoreCase);\u003Cbr \/\u003E    }\u003Cbr \/\u003E    else                                   \/\/ No switch identified\u003Cbr \/\u003E    {\u003Cbr \/\u003E        \/* No need to left shift the array of strings as there is no switch *\/\u003Cbr \/\u003E\u003Cbr \/\u003E        printf(\"\\nNo switch detected. Sorting lexicographically:\\n\");\u003Cbr \/\u003E        sort(argc, argv, compStr);\u003Cbr \/\u003E    }\u003Cbr \/\u003E\u003Cbr \/\u003E    \/* Print the result *\/\u003Cbr \/\u003E    for(i = 1; i \u0026lt; argc; i++)\u003Cbr \/\u003E            printf(\"%s\\n\", argv[i]);\u003Cbr \/\u003E\u003Cbr \/\u003E    return 0;\u003Cbr \/\u003E}\u003Cbr \/\u003E\u003C\/pre\u003E\u003Cbr \/\u003EThe above program runs like this:\u003Cbr \/\u003E\u003Cpre class=\"output\"\u003E.\/a.out geek factorial\u003Cbr \/\u003ENo switch detected. Sorting lexicographically:\u003Cbr \/\u003Efactorial\u003Cbr \/\u003Egeek\u003Cbr \/\u003E\u003Cbr \/\u003E.\/a.out -n 67 45 23 32\u003Cbr \/\u003ESwitch -n detected. Sorting numerically:\u003Cbr \/\u003E23\u003Cbr \/\u003E32\u003Cbr \/\u003E45\u003Cbr \/\u003E67\u003Cbr \/\u003E\u003Cbr \/\u003E.\/a.out -r 67 45 23 32\u003Cbr \/\u003ESwitch -r detected. Sorting numerically in reverse:\u003Cbr \/\u003E67\u003Cbr \/\u003E45\u003Cbr \/\u003E32\u003Cbr \/\u003E23\u003Cbr \/\u003E \u003Cbr \/\u003E.\/a.out\u003Cbr \/\u003ENo input command line arguments provided.\u003Cbr \/\u003E\u003C\/pre\u003E\u003C\/div\u003E"},"link":[{"rel":"replies","type":"application/atom+xml","href":"https:\/\/geekfactorial.blogspot.com\/feeds\/6020248845689795675\/comments\/default","title":"Post Comments"},{"rel":"replies","type":"text/html","href":"https:\/\/geekfactorial.blogspot.com\/2016\/08\/implement-a-program-that-sorts-given-data-according-to-the-switch-provided-by-the-user.html#comment-form","title":"0 Comments"},{"rel":"edit","type":"application/atom+xml","href":"https:\/\/www.blogger.com\/feeds\/4840603379647116080\/posts\/default\/6020248845689795675"},{"rel":"self","type":"application/atom+xml","href":"https:\/\/www.blogger.com\/feeds\/4840603379647116080\/posts\/default\/6020248845689795675"},{"rel":"alternate","type":"text/html","href":"https:\/\/geekfactorial.blogspot.com\/2016\/08\/implement-a-program-that-sorts-given-data-according-to-the-switch-provided-by-the-user.html","title":"Implement a program that sorts given data according to the switch provided by the user"}],"author":[{"name":{"$t":"Unknown"},"email":{"$t":"noreply@blogger.com"},"gd$image":{"rel":"http://schemas.google.com/g/2005#thumbnail","width":"16","height":"16","src":"https:\/\/img1.blogblog.com\/img\/b16-rounded.gif"}}],"thr$total":{"$t":"0"}},{"id":{"$t":"tag:blogger.com,1999:blog-4840603379647116080.post-9076681999996329860"},"published":{"$t":"2016-08-14T10:47:00.000+05:30"},"updated":{"$t":"2016-08-14T10:54:46.848+05:30"},"category":[{"scheme":"http://www.blogger.com/atom/ns#","term":"java"},{"scheme":"http://www.blogger.com/atom/ns#","term":"programming"}],"title":{"type":"text","$t":"Command line arguments in Java"},"content":{"type":"html","$t":"\u003Cdiv dir=\"ltr\" style=\"text-align: left;\" trbidi=\"on\"\u003ECommand line arguments constitute the additional information that can be passed to a program at the time of its execution via command line. They are given just after the program's name on the command line interface of the operating system.\u003Cbr \/\u003E\u003Cbr \/\u003EYou can read more about the use of command line arguments \u003Ca href=\"https:\/\/geekfactorial.blogspot.com\/2016\/08\/command-line-arguments-and-their-implementation-in-c.html\"\u003Ehere\u003C\/a\u003E.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cbig\u003E\u003Cb\u003ECommand line arguments in Java:\u003C\/b\u003E\u003C\/big\u003E\u003Cbr \/\u003EThe arguments passed from the console can be received in a Java program via the argument variable in its main function. To use command line arguments in your Java program, you must first understand the declaration of the main function. There is an array of Strings present within the declaration of the main method, generally named as String[] args (since args is nothing more than an identifier, we can replace it with any other name). Now what we need to know is how a String array can be passed as an argument when we execute the program. We pass it through the command line itself.\u003Cbr \/\u003E\u003Cbr \/\u003EConsider that we have a class named Add. The following statement is normally used to execute the program: \u003Cb\u003E\u003Ci\u003Ejava Add\u003C\/i\u003E\u003C\/b\u003E\u003Cbr \/\u003EIf we wish to pass the String array, we simply write the elements of the array after the class name. Enclosing the Strings in quotes is optional. Consecutive Strings are separated with a space. For example, if we wish to pass two Strings as arguments, containing the values \"15\" and \"3\", then any of the following lines can be entered on the command prompt: \u003Cb\u003E\u003Ci\u003Ejava Add 15 3\u003C\/i\u003E\u003C\/b\u003E or \u003Cb\u003E\u003Ci\u003Ejava Add \"15\" \"3\"\u003C\/i\u003E\u003C\/b\u003E\u003Cbr \/\u003E\u003Cbr \/\u003ESince these arguments are passed through the command line, they are known as command line arguments. The String arguments passed are stored in the array of Strings specified in the main function's header. In the above example, args[] will contain two Strings, \"15\" and \"3\". These elements are accessed in the same way as the elements of a normal array. Note that \u003Ci\u003Eunlike C, Java does not store the program file's name as a command line argument\u003C\/i\u003E. The following is a complete program which displays the sum of numbers passed as command line arguments.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cpre class=\"brush:java; code\"\u003E\/* Java program to display sum of all given numbers via command line arguments: *\/\u003Cbr \/\u003E\u003Cbr \/\u003Epublic class Add {\u003Cbr \/\u003E\u003Cbr \/\u003E    public static void main (String[] args) {\u003Cbr \/\u003E        int sum = 0;\u003Cbr \/\u003E\u003Cbr \/\u003E        if (args.length == 0)\u003Cbr \/\u003E            System.out.println (\"No arguments provided.\");\u003Cbr \/\u003E        else {\u003Cbr \/\u003E            for (int i = 0; i \u003C args.length; i++)\u003Cbr \/\u003E                sum += Integer.parseInt (args[i]);    \/\/ Convert string args[i] to integer\u003Cbr \/\u003E\u003Cbr \/\u003E            System.out.println (\"Sum of provided numbers: \" + sum);\u003Cbr \/\u003E        }\u003Cbr \/\u003E    }\u003Cbr \/\u003E}\u003Cbr \/\u003E\u003C\/pre\u003EThe above program works like this:  \u003Cpre class=\"output\"\u003Ejava Add\u003Cbr \/\u003ENo arguments provided.\u003Cbr \/\u003E\u003Cbr \/\u003Ejava Add 15 3\u003Cbr \/\u003ESum of provided numbers: 18\u003Cbr \/\u003E\u003Cbr \/\u003Ejava Add \"15\" \"3\"\u003Cbr \/\u003ESum of provided numbers: 18\u003Cbr \/\u003E\u003C\/pre\u003E\u003C\/div\u003E"},"link":[{"rel":"replies","type":"application/atom+xml","href":"https:\/\/geekfactorial.blogspot.com\/feeds\/9076681999996329860\/comments\/default","title":"Post Comments"},{"rel":"replies","type":"text/html","href":"https:\/\/geekfactorial.blogspot.com\/2016\/08\/command-line-arguments-in-java.html#comment-form","title":"0 Comments"},{"rel":"edit","type":"application/atom+xml","href":"https:\/\/www.blogger.com\/feeds\/4840603379647116080\/posts\/default\/9076681999996329860"},{"rel":"self","type":"application/atom+xml","href":"https:\/\/www.blogger.com\/feeds\/4840603379647116080\/posts\/default\/9076681999996329860"},{"rel":"alternate","type":"text/html","href":"https:\/\/geekfactorial.blogspot.com\/2016\/08\/command-line-arguments-in-java.html","title":"Command line arguments in Java"}],"author":[{"name":{"$t":"Unknown"},"email":{"$t":"noreply@blogger.com"},"gd$image":{"rel":"http://schemas.google.com/g/2005#thumbnail","width":"16","height":"16","src":"https:\/\/img1.blogblog.com\/img\/b16-rounded.gif"}}],"thr$total":{"$t":"0"}},{"id":{"$t":"tag:blogger.com,1999:blog-4840603379647116080.post-6492476952885493266"},"published":{"$t":"2016-08-14T01:30:00.000+05:30"},"updated":{"$t":"2016-08-14T10:57:12.898+05:30"},"category":[{"scheme":"http://www.blogger.com/atom/ns#","term":"c"},{"scheme":"http://www.blogger.com/atom/ns#","term":"programming"}],"title":{"type":"text","$t":"Command line arguments and their implementation in C"},"content":{"type":"html","$t":"\u003Cdiv dir=\"ltr\" style=\"text-align: left;\" trbidi=\"on\"\u003EMany programs allow command-line arguments to be specified when they are run. Command line arguments are used to pass any additional information to a program when it is executed via command line interface. It is the information that follows the program's name on the command line of the operating system.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cbig\u003E\u003Cb\u003EWhy are command line arguments useful?\u003C\/b\u003E\u003C\/big\u003E\u003Cbr \/\u003ECommand line arguments allow the user to pass additional parameters while running a program, so that it can behave in many different ways based on the user's request.\u003Cbr \/\u003E\u003Cbr \/\u003EFor example, if we use the \u003Cb\u003E\u003Ci\u003Els\u003C\/i\u003E\u003C\/b\u003E command on Unix\/Linux to list the files in a directory, we get the list of files in some default format. Now if we give the command \u003Cb\u003E\u003Ci\u003Els -l\u003C\/i\u003E\u003C\/b\u003E, we get the contents in a long listing format with details like owner, permissions etc. The \u003Cb\u003E\u003Ci\u003E-l\u003C\/i\u003E\u003C\/b\u003E part can be considered as a command line argument (or \"switch\" in Linux).\u003Cbr \/\u003E\u003Cbr \/\u003ESimilarly, when you use a text editor, you may specify the name of the file you want to edit after the name of the editor program. For example, a command like \u003Cb\u003E\u003Ci\u003Eemacs myfile\u003C\/i\u003E\u003C\/b\u003E will open the file named \"myfile\" in the editor \"Emacs\".\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cbig\u003E\u003Cb\u003ECommand line arguments in C:\u003C\/b\u003E\u003C\/big\u003E\u003Cbr \/\u003ETo use command line arguments in a C program, you must first understand the full declaration of the main function. Main can generally accept two arguments - one is the number of command line arguments passed to it, and the other is the actual list of all of the command line arguments. The full declaration of main looks like this:\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cpre class=\"brush:cpp; code\"\u003Eint main (int argc, char *argv[])\u003Cbr \/\u003E\u003C\/pre\u003EOr this:\u003Cbr \/\u003E\u003Cpre class=\"brush:cpp; code\"\u003Eint main (int argc, char** argv) \u003Cbr \/\u003E\u003C\/pre\u003E\u003Cbr \/\u003EThe integer \u003Cb\u003Eargc\u003C\/b\u003E is the \u003Cb\u003Earg\u003C\/b\u003Eument \u003Cb\u003Ec\u003C\/b\u003Eount (i.e. the number of arguments passed into the program from command line, \u003Ci\u003Eincluding the name of the program\u003C\/i\u003E). The array of character pointers \u003Cb\u003Eargv\u003C\/b\u003E is the listing of all the \u003Cb\u003Earg\u003C\/b\u003Eument \u003Cb\u003Ev\u003C\/b\u003Eariables (i.e. pointers to strings containing the command line arguments). Some interesting things are to be noted here:\u003Cbr \/\u003E\u003Cul style=\"text-align: left;\"\u003E\u003Cli\u003EThe first argument, argv[0], is the name of the program, or an empty string if the name is not available. Hence, if no arguments are supplied, argument count (argc) will be one and the only command line argument available will be the program file name.\u003C\/li\u003E\u003Cli\u003EAfter that, every element number less than argc is a command line argument. You can use each argv element just like a string (or use argv as a two dimensional array).\u003C\/li\u003E\u003Cli\u003EAt last, the pointer argv[argc] is a null pointer.\u003C\/li\u003E\u003C\/ul\u003EFor example, if a C program is run via a command such as \u003Cb\u003E\u003Ci\u003E.\/a.out apple ball cat\u003C\/i\u003E\u003C\/b\u003E, then the command-line variables will hold the following values:\u003Cbr \/\u003E\u003Cbr \/\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; argc = 4\u003Cbr \/\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; argv[0] = \".\/a.out\" (the file name)\u003Cbr \/\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; argv[1] = \"apple\"\u003Cbr \/\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; argv[2] = \"ball\"\u003Cbr \/\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; argv[3] = \"cat\"\u003Cbr \/\u003E\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; argv[4] = (null)\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cbig\u003E\u003Cb\u003EHow can this concept be implemented?\u003C\/b\u003E\u003C\/big\u003E\u003Cbr \/\u003EAlmost any program that wants its parameters to be set when it is executed would use this concept. Let us make a C program that takes numbers as command line arguments and displays their sum.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cpre class=\"brush:cpp; code\"\u003E\/* C program to display the sum of all given numbers via command line arguments: *\/\u003Cbr \/\u003E\u003Cbr \/\u003E#include \u0026lt;stdio.h\u0026gt;\u003Cbr \/\u003E\u003Cbr \/\u003Eint main (int argc, char *argv[]) {\u003Cbr \/\u003E\u003Cbr \/\u003E    int sum = 0, i, num;\u003Cbr \/\u003E\u003Cbr \/\u003E    if (argc \u0026lt; 2) {\u003Cbr \/\u003E        printf (\"No arguments provided.\\n\");\u003Cbr \/\u003E        return 0;\u003Cbr \/\u003E    }\u003Cbr \/\u003E\u003Cbr \/\u003E    for (i = 1; i \u0026lt; argc; i++) {\u003Cbr \/\u003E        sscanf (argv[i], \"%d\", \u0026amp;num);    \/\/ Convert string argv[i] to number num\u003Cbr \/\u003E        sum += num;\u003Cbr \/\u003E    }\u003Cbr \/\u003E\u003Cbr \/\u003E    printf (\"Sum of provided numbers: %d\\n\", sum);\u003Cbr \/\u003E    return 0;\u003Cbr \/\u003E}\u003Cbr \/\u003E\u003C\/pre\u003EThe above program works like this:\u003Cbr \/\u003E\u003Cpre class=\"output\"\u003E.\/a.out\u003Cbr \/\u003ENo arguments provided.\u003Cbr \/\u003E\u003Cbr \/\u003E.\/a.out 10 2 3\u003Cbr \/\u003ESum of provided numbers: 15 \u003Cbr \/\u003E\u003C\/pre\u003E\u003Cbr \/\u003E\u003Cb\u003EAlso see:\u003C\/b\u003E \u003Ca href=\"https:\/\/geekfactorial.blogspot.com\/2016\/08\/command-line-arguments-in-java.html\"\u003ECommand line arguments in Java\u003C\/a\u003E\u003Cbr \/\u003E\u003C\/div\u003E"},"link":[{"rel":"replies","type":"application/atom+xml","href":"https:\/\/geekfactorial.blogspot.com\/feeds\/6492476952885493266\/comments\/default","title":"Post Comments"},{"rel":"replies","type":"text/html","href":"https:\/\/geekfactorial.blogspot.com\/2016\/08\/command-line-arguments-and-their-implementation-in-c.html#comment-form","title":"0 Comments"},{"rel":"edit","type":"application/atom+xml","href":"https:\/\/www.blogger.com\/feeds\/4840603379647116080\/posts\/default\/6492476952885493266"},{"rel":"self","type":"application/atom+xml","href":"https:\/\/www.blogger.com\/feeds\/4840603379647116080\/posts\/default\/6492476952885493266"},{"rel":"alternate","type":"text/html","href":"https:\/\/geekfactorial.blogspot.com\/2016\/08\/command-line-arguments-and-their-implementation-in-c.html","title":"Command line arguments and their implementation in C"}],"author":[{"name":{"$t":"Unknown"},"email":{"$t":"noreply@blogger.com"},"gd$image":{"rel":"http://schemas.google.com/g/2005#thumbnail","width":"16","height":"16","src":"https:\/\/img1.blogblog.com\/img\/b16-rounded.gif"}}],"thr$total":{"$t":"0"}}]}});